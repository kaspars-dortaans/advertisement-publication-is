//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.4.0.0 (NJsonSchema v11.3.2.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import axios, { AxiosError } from 'axios';
import type { AxiosInstance, AxiosRequestConfig, AxiosResponse, CancelToken } from 'axios';

export class AdvertisementClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    /**
     * @param body (optional) 
     * @return OK
     */
    getAdvertisements(body: AdvertisementQuery | undefined, cancelToken?: CancelToken): Promise<AdvertisementListItemDataTableQueryResponse> {
        let url_ = this.baseUrl + "/api/Advertisement/GetAdvertisements";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAdvertisements(_response);
        });
    }

    protected processGetAdvertisements(response: AxiosResponse): Promise<AdvertisementListItemDataTableQueryResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = AdvertisementListItemDataTableQueryResponse.fromJS(resultData200);
            return Promise.resolve<AdvertisementListItemDataTableQueryResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<AdvertisementListItemDataTableQueryResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    getBookmarkedAdvertisements(body: AdvertisementQuery | undefined, cancelToken?: CancelToken): Promise<AdvertisementListItemDataTableQueryResponse> {
        let url_ = this.baseUrl + "/api/Advertisement/GetBookmarkedAdvertisements";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetBookmarkedAdvertisements(_response);
        });
    }

    protected processGetBookmarkedAdvertisements(response: AxiosResponse): Promise<AdvertisementListItemDataTableQueryResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = AdvertisementListItemDataTableQueryResponse.fromJS(resultData200);
            return Promise.resolve<AdvertisementListItemDataTableQueryResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<AdvertisementListItemDataTableQueryResponse>(null as any);
    }

    /**
     * @param advertisementId (optional) 
     * @return OK
     */
    getAdvertisement(advertisementId: number | undefined, cancelToken?: CancelToken): Promise<AdvertisementDto> {
        let url_ = this.baseUrl + "/api/Advertisement/GetAdvertisement?";
        if (advertisementId === null)
            throw new Error("The parameter 'advertisementId' cannot be null.");
        else if (advertisementId !== undefined)
            url_ += "advertisementId=" + encodeURIComponent("" + advertisementId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAdvertisement(_response);
        });
    }

    protected processGetAdvertisement(response: AxiosResponse): Promise<AdvertisementDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = AdvertisementDto.fromJS(resultData200);
            return Promise.resolve<AdvertisementDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<AdvertisementDto>(null as any);
    }

    /**
     * @param advertisementId (optional) 
     * @return OK
     */
    revealAdvertiserPhoneNumber(advertisementId: number | undefined, cancelToken?: CancelToken): Promise<string> {
        let url_ = this.baseUrl + "/api/Advertisement/RevealAdvertiserPhoneNumber?";
        if (advertisementId === null)
            throw new Error("The parameter 'advertisementId' cannot be null.");
        else if (advertisementId !== undefined)
            url_ += "advertisementId=" + encodeURIComponent("" + advertisementId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRevealAdvertiserPhoneNumber(_response);
        });
    }

    protected processRevealAdvertiserPhoneNumber(response: AxiosResponse): Promise<string> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<string>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ForbidResult.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<string>(null as any);
    }

    /**
     * @param advertisementId (optional) 
     * @return OK
     */
    revealAdvertiserEmail(advertisementId: number | undefined, cancelToken?: CancelToken): Promise<string> {
        let url_ = this.baseUrl + "/api/Advertisement/RevealAdvertiserEmail?";
        if (advertisementId === null)
            throw new Error("The parameter 'advertisementId' cannot be null.");
        else if (advertisementId !== undefined)
            url_ += "advertisementId=" + encodeURIComponent("" + advertisementId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRevealAdvertiserEmail(_response);
        });
    }

    protected processRevealAdvertiserEmail(response: AxiosResponse): Promise<string> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<string>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ForbidResult.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<string>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    bookmarkAdvertisement(body: BookmarkAdvertisementRequest | undefined, cancelToken?: CancelToken): Promise<OkResult> {
        let url_ = this.baseUrl + "/api/Advertisement/BookmarkAdvertisement";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processBookmarkAdvertisement(_response);
        });
    }

    protected processBookmarkAdvertisement(response: AxiosResponse): Promise<OkResult> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = OkResult.fromJS(resultData200);
            return Promise.resolve<OkResult>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RequestExceptionResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<OkResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    removeAdvertisementBookmarks(body: number[] | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/Advertisement/RemoveAdvertisementBookmarks";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRemoveAdvertisementBookmarks(_response);
        });
    }

    protected processRemoveAdvertisementBookmarks(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return OK
     */
    getBookmarkedAdvertisementCategoryList( cancelToken?: CancelToken): Promise<Int32StringKeyValuePair[]> {
        let url_ = this.baseUrl + "/api/Advertisement/GetBookmarkedAdvertisementCategoryList";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetBookmarkedAdvertisementCategoryList(_response);
        });
    }

    protected processGetBookmarkedAdvertisementCategoryList(response: AxiosResponse): Promise<Int32StringKeyValuePair[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Int32StringKeyValuePair.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<Int32StringKeyValuePair[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Int32StringKeyValuePair[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    reportAdvertisement(body: ReportAdvertisementRequest | undefined, cancelToken?: CancelToken): Promise<OkResult> {
        let url_ = this.baseUrl + "/api/Advertisement/ReportAdvertisement";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processReportAdvertisement(_response);
        });
    }

    protected processReportAdvertisement(response: AxiosResponse): Promise<OkResult> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = OkResult.fromJS(resultData200);
            return Promise.resolve<OkResult>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RequestExceptionResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<OkResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    getOwnedAdvertisements(body: DataTableQuery | undefined, cancelToken?: CancelToken): Promise<AdvertisementInfoDataTableQueryResponse> {
        let url_ = this.baseUrl + "/api/Advertisement/GetOwnedAdvertisements";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetOwnedAdvertisements(_response);
        });
    }

    protected processGetOwnedAdvertisements(response: AxiosResponse): Promise<AdvertisementInfoDataTableQueryResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = AdvertisementInfoDataTableQueryResponse.fromJS(resultData200);
            return Promise.resolve<AdvertisementInfoDataTableQueryResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<AdvertisementInfoDataTableQueryResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    setIsActiveAdvertisements(body: SetActiveStatusRequest | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/Advertisement/SetIsActiveAdvertisements";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSetIsActiveAdvertisements(_response);
        });
    }

    protected processSetIsActiveAdvertisements(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    deleteAdvertisements(body: number[] | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/Advertisement/DeleteAdvertisements";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDeleteAdvertisements(_response);
        });
    }

    protected processDeleteAdvertisements(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param id (optional) 
     * @param categoryId (optional) 
     * @param attributeValues (optional) 
     * @param postTime (optional) 
     * @param validToDate (optional) 
     * @param title (optional) 
     * @param description (optional) 
     * @param imagesToAdd (optional) 
     * @param imageOrder (optional) 
     * @return OK
     */
    createAdvertisement(id: number | null | undefined, categoryId: number | undefined, attributeValues: Int32StringKeyValuePair[] | null | undefined, postTime: PostTimeDto | null | undefined, validToDate: Date | null | undefined, title: string | undefined, description: string | undefined, imagesToAdd: FileParameter[] | null | undefined, imageOrder: ImageDto[] | null | undefined, cancelToken?: CancelToken): Promise<number> {
        let url_ = this.baseUrl + "/api/Advertisement/CreateAdvertisement";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (id !== null && id !== undefined)
            content_.append("id", id.toString());
        if (categoryId === null || categoryId === undefined)
            throw new Error("The parameter 'categoryId' cannot be null.");
        else
            content_.append("categoryId", categoryId.toString());
        if (attributeValues !== null && attributeValues !== undefined)
            attributeValues.forEach((item_, i) => {
                if(item_.key != null)
                    content_.append("attributeValues[" + i + "].key", "" + item_.key)
                if(item_.value != null)
                    content_.append("attributeValues[" + i + "].value", "" + item_.value)
            });
        if (postTime !== null && postTime !== undefined)
        {
            if(postTime.days != null)
                content_.append("postTime.days", "" + postTime.days)
            if(postTime.weeks != null)
                content_.append("postTime.weeks", "" + postTime.weeks)
            if(postTime.months != null)
                content_.append("postTime.months", "" + postTime.months)
        }
        if (validToDate !== null && validToDate !== undefined)
            content_.append("validToDate", validToDate.toJSON());
        if (title === null || title === undefined)
            throw new Error("The parameter 'title' cannot be null.");
        else
            content_.append("title", title.toString());
        if (description === null || description === undefined)
            throw new Error("The parameter 'description' cannot be null.");
        else
            content_.append("description", description.toString());
        if (imagesToAdd !== null && imagesToAdd !== undefined)
            imagesToAdd.forEach(item_ => content_.append("imagesToAdd", item_.data, item_.fileName ? item_.fileName : "imagesToAdd") );
        if (imageOrder !== null && imageOrder !== undefined)
            imageOrder.forEach((item_, i) => {
                if(item_.id != null)
                    content_.append("imageOrder[" + i + "].id", "" + item_.id)
                if(item_.imageURLs != null)
                    content_.append("imageOrder[" + i + "].imageURLs", "" + item_.imageURLs)
                if(item_.hash != null)
                    content_.append("imageOrder[" + i + "].hash", "" + item_.hash)
            });

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateAdvertisement(_response);
        });
    }

    protected processCreateAdvertisement(response: AxiosResponse): Promise<number> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<number>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RequestExceptionResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<number>(null as any);
    }

    /**
     * @param advertisementId (optional) 
     * @return OK
     */
    editAdvertisementGet(advertisementId: number | undefined, cancelToken?: CancelToken): Promise<AdvertisementFormInfo> {
        let url_ = this.baseUrl + "/api/Advertisement/EditAdvertisement?";
        if (advertisementId === null)
            throw new Error("The parameter 'advertisementId' cannot be null.");
        else if (advertisementId !== undefined)
            url_ += "advertisementId=" + encodeURIComponent("" + advertisementId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processEditAdvertisementGet(_response);
        });
    }

    protected processEditAdvertisementGet(response: AxiosResponse): Promise<AdvertisementFormInfo> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = AdvertisementFormInfo.fromJS(resultData200);
            return Promise.resolve<AdvertisementFormInfo>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RequestExceptionResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<AdvertisementFormInfo>(null as any);
    }

    /**
     * @param id (optional) 
     * @param categoryId (optional) 
     * @param attributeValues (optional) 
     * @param postTime (optional) 
     * @param validToDate (optional) 
     * @param title (optional) 
     * @param description (optional) 
     * @param imagesToAdd (optional) 
     * @param imageOrder (optional) 
     * @return OK
     */
    editAdvertisementPost(id: number | null | undefined, categoryId: number | undefined, attributeValues: Int32StringKeyValuePair[] | null | undefined, postTime: PostTimeDto | null | undefined, validToDate: Date | null | undefined, title: string | undefined, description: string | undefined, imagesToAdd: FileParameter[] | null | undefined, imageOrder: ImageDto[] | null | undefined, cancelToken?: CancelToken): Promise<OkResult> {
        let url_ = this.baseUrl + "/api/Advertisement/EditAdvertisement";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (id !== null && id !== undefined)
            content_.append("id", id.toString());
        if (categoryId === null || categoryId === undefined)
            throw new Error("The parameter 'categoryId' cannot be null.");
        else
            content_.append("categoryId", categoryId.toString());
        if (attributeValues !== null && attributeValues !== undefined)
            attributeValues.forEach((item_, i) => {
                if(item_.key != null)
                    content_.append("attributeValues[" + i + "].key", "" + item_.key)
                if(item_.value != null)
                    content_.append("attributeValues[" + i + "].value", "" + item_.value)
            });
        if (postTime !== null && postTime !== undefined)
        {
            if(postTime.days != null)
                content_.append("postTime.days", "" + postTime.days)
            if(postTime.weeks != null)
                content_.append("postTime.weeks", "" + postTime.weeks)
            if(postTime.months != null)
                content_.append("postTime.months", "" + postTime.months)
        }
        if (validToDate !== null && validToDate !== undefined)
            content_.append("validToDate", validToDate.toJSON());
        if (title === null || title === undefined)
            throw new Error("The parameter 'title' cannot be null.");
        else
            content_.append("title", title.toString());
        if (description === null || description === undefined)
            throw new Error("The parameter 'description' cannot be null.");
        else
            content_.append("description", description.toString());
        if (imagesToAdd !== null && imagesToAdd !== undefined)
            imagesToAdd.forEach(item_ => content_.append("imagesToAdd", item_.data, item_.fileName ? item_.fileName : "imagesToAdd") );
        if (imageOrder !== null && imageOrder !== undefined)
            imageOrder.forEach((item_, i) => {
                if(item_.id != null)
                    content_.append("imageOrder[" + i + "].id", "" + item_.id)
                if(item_.imageURLs != null)
                    content_.append("imageOrder[" + i + "].imageURLs", "" + item_.imageURLs)
                if(item_.hash != null)
                    content_.append("imageOrder[" + i + "].hash", "" + item_.hash)
            });

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processEditAdvertisementPost(_response);
        });
    }

    protected processEditAdvertisementPost(response: AxiosResponse): Promise<OkResult> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = OkResult.fromJS(resultData200);
            return Promise.resolve<OkResult>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RequestExceptionResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<OkResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    getAdvertisementLookupByIds(body: number[] | undefined, cancelToken?: CancelToken): Promise<Int32StringKeyValuePair[]> {
        let url_ = this.baseUrl + "/api/Advertisement/GetAdvertisementLookupByIds";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAdvertisementLookupByIds(_response);
        });
    }

    protected processGetAdvertisementLookupByIds(response: AxiosResponse): Promise<Int32StringKeyValuePair[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Int32StringKeyValuePair.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<Int32StringKeyValuePair[]>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RequestExceptionResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Int32StringKeyValuePair[]>(null as any);
    }
}

export class AdvertisementNotificationClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    /**
     * @param body (optional) 
     * @return OK
     */
    getAdvertisementNotificationSubscriptions(body: DataTableQuery | undefined, cancelToken?: CancelToken): Promise<NotificationSubscriptionItemDataTableQueryResponse> {
        let url_ = this.baseUrl + "/api/AdvertisementNotification/GetAdvertisementNotificationSubscriptions";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAdvertisementNotificationSubscriptions(_response);
        });
    }

    protected processGetAdvertisementNotificationSubscriptions(response: AxiosResponse): Promise<NotificationSubscriptionItemDataTableQueryResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = NotificationSubscriptionItemDataTableQueryResponse.fromJS(resultData200);
            return Promise.resolve<NotificationSubscriptionItemDataTableQueryResponse>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RequestExceptionResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<NotificationSubscriptionItemDataTableQueryResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    getSubscriptionsLookupByIds(body: number[] | undefined, cancelToken?: CancelToken): Promise<Int32StringKeyValuePair[]> {
        let url_ = this.baseUrl + "/api/AdvertisementNotification/GetSubscriptionsLookupByIds";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetSubscriptionsLookupByIds(_response);
        });
    }

    protected processGetSubscriptionsLookupByIds(response: AxiosResponse): Promise<Int32StringKeyValuePair[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Int32StringKeyValuePair.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<Int32StringKeyValuePair[]>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RequestExceptionResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Int32StringKeyValuePair[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    createSubscriptions(body: CreateOrEditNotificationSubscriptionRequest | undefined, cancelToken?: CancelToken): Promise<number> {
        let url_ = this.baseUrl + "/api/AdvertisementNotification/CreateSubscriptions";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateSubscriptions(_response);
        });
    }

    protected processCreateSubscriptions(response: AxiosResponse): Promise<number> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<number>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RequestExceptionResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<number>(null as any);
    }

    /**
     * @param subscriptionId (optional) 
     * @return OK
     */
    editSubscriptionsGet(subscriptionId: number | undefined, cancelToken?: CancelToken): Promise<SubscriptionFormInfo> {
        let url_ = this.baseUrl + "/api/AdvertisementNotification/EditSubscriptions?";
        if (subscriptionId === null)
            throw new Error("The parameter 'subscriptionId' cannot be null.");
        else if (subscriptionId !== undefined)
            url_ += "subscriptionId=" + encodeURIComponent("" + subscriptionId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processEditSubscriptionsGet(_response);
        });
    }

    protected processEditSubscriptionsGet(response: AxiosResponse): Promise<SubscriptionFormInfo> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = SubscriptionFormInfo.fromJS(resultData200);
            return Promise.resolve<SubscriptionFormInfo>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RequestExceptionResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<SubscriptionFormInfo>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    editSubscriptionsPost(body: CreateOrEditNotificationSubscriptionRequest | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/AdvertisementNotification/EditSubscriptions";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processEditSubscriptionsPost(_response);
        });
    }

    protected processEditSubscriptionsPost(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RequestExceptionResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    setSubscriptionActiveStatus(body: SetActiveStatusRequest | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/AdvertisementNotification/SetSubscriptionActiveStatus";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSetSubscriptionActiveStatus(_response);
        });
    }

    protected processSetSubscriptionActiveStatus(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RequestExceptionResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    deleteSubscriptions(body: number[] | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/AdvertisementNotification/DeleteSubscriptions";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDeleteSubscriptions(_response);
        });
    }

    protected processDeleteSubscriptions(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RequestExceptionResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }
}

export class CategoryClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    /**
     * @return OK
     */
    getCategories( cancelToken?: CancelToken): Promise<CategoryItem[]> {
        let url_ = this.baseUrl + "/api/Category/GetCategories";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetCategories(_response);
        });
    }

    protected processGetCategories(response: AxiosResponse): Promise<CategoryItem[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CategoryItem.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<CategoryItem[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CategoryItem[]>(null as any);
    }

    /**
     * @return OK
     */
    getCategoryLookup( cancelToken?: CancelToken): Promise<Int32StringKeyValuePair[]> {
        let url_ = this.baseUrl + "/api/Category/GetCategoryLookup";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetCategoryLookup(_response);
        });
    }

    protected processGetCategoryLookup(response: AxiosResponse): Promise<Int32StringKeyValuePair[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Int32StringKeyValuePair.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<Int32StringKeyValuePair[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Int32StringKeyValuePair[]>(null as any);
    }

    /**
     * @return OK
     */
    getAttributeLookup( cancelToken?: CancelToken): Promise<Int32StringKeyValuePair[]> {
        let url_ = this.baseUrl + "/api/Category/GetAttributeLookup";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAttributeLookup(_response);
        });
    }

    protected processGetAttributeLookup(response: AxiosResponse): Promise<Int32StringKeyValuePair[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Int32StringKeyValuePair.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<Int32StringKeyValuePair[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Int32StringKeyValuePair[]>(null as any);
    }

    /**
     * @param categoryId (optional) 
     * @return OK
     */
    getCategoryInfo(categoryId: number | undefined, cancelToken?: CancelToken): Promise<CategoryInfo> {
        let url_ = this.baseUrl + "/api/Category/GetCategoryInfo?";
        if (categoryId === null)
            throw new Error("The parameter 'categoryId' cannot be null.");
        else if (categoryId !== undefined)
            url_ += "categoryId=" + encodeURIComponent("" + categoryId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetCategoryInfo(_response);
        });
    }

    protected processGetCategoryInfo(response: AxiosResponse): Promise<CategoryInfo> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = CategoryInfo.fromJS(resultData200);
            return Promise.resolve<CategoryInfo>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CategoryInfo>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    getCategoryListFromAdvertisementIds(body: number[] | undefined, cancelToken?: CancelToken): Promise<Int32StringKeyValuePair[]> {
        let url_ = this.baseUrl + "/api/Category/GetCategoryListFromAdvertisementIds";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetCategoryListFromAdvertisementIds(_response);
        });
    }

    protected processGetCategoryListFromAdvertisementIds(response: AxiosResponse): Promise<Int32StringKeyValuePair[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Int32StringKeyValuePair.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<Int32StringKeyValuePair[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Int32StringKeyValuePair[]>(null as any);
    }

    /**
     * @param categoryId (optional) 
     * @return OK
     */
    getCategoryAttributeInfo(categoryId: number | undefined, cancelToken?: CancelToken): Promise<CategoryAttributeListData> {
        let url_ = this.baseUrl + "/api/Category/GetCategoryAttributeInfo?";
        if (categoryId === null)
            throw new Error("The parameter 'categoryId' cannot be null.");
        else if (categoryId !== undefined)
            url_ += "categoryId=" + encodeURIComponent("" + categoryId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetCategoryAttributeInfo(_response);
        });
    }

    protected processGetCategoryAttributeInfo(response: AxiosResponse): Promise<CategoryAttributeListData> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = CategoryAttributeListData.fromJS(resultData200);
            return Promise.resolve<CategoryAttributeListData>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CategoryAttributeListData>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    createCategory(body: PutCategoryRequest | undefined, cancelToken?: CancelToken): Promise<OkResult> {
        let url_ = this.baseUrl + "/api/Category/CreateCategory";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateCategory(_response);
        });
    }

    protected processCreateCategory(response: AxiosResponse): Promise<OkResult> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = OkResult.fromJS(resultData200);
            return Promise.resolve<OkResult>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RequestExceptionResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<OkResult>(null as any);
    }

    /**
     * @param categoryId (optional) 
     * @return OK
     */
    getCategoryFormInfo(categoryId: number | undefined, cancelToken?: CancelToken): Promise<PutCategoryRequest> {
        let url_ = this.baseUrl + "/api/Category/GetCategoryFormInfo?";
        if (categoryId === null)
            throw new Error("The parameter 'categoryId' cannot be null.");
        else if (categoryId !== undefined)
            url_ += "categoryId=" + encodeURIComponent("" + categoryId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetCategoryFormInfo(_response);
        });
    }

    protected processGetCategoryFormInfo(response: AxiosResponse): Promise<PutCategoryRequest> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PutCategoryRequest.fromJS(resultData200);
            return Promise.resolve<PutCategoryRequest>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RequestExceptionResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PutCategoryRequest>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    editCategory(body: PutCategoryRequest | undefined, cancelToken?: CancelToken): Promise<OkResult> {
        let url_ = this.baseUrl + "/api/Category/EditCategory";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processEditCategory(_response);
        });
    }

    protected processEditCategory(response: AxiosResponse): Promise<OkResult> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = OkResult.fromJS(resultData200);
            return Promise.resolve<OkResult>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RequestExceptionResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<OkResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    deleteCategory(body: number[] | undefined, cancelToken?: CancelToken): Promise<OkResult> {
        let url_ = this.baseUrl + "/api/Category/DeleteCategory";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDeleteCategory(_response);
        });
    }

    protected processDeleteCategory(response: AxiosResponse): Promise<OkResult> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = OkResult.fromJS(resultData200);
            return Promise.resolve<OkResult>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RequestExceptionResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<OkResult>(null as any);
    }
}

export class FileClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    /**
     * @param id (optional) 
     * @param getThumbnail (optional) 
     * @return OK
     */
    getFile(id: number | undefined, getThumbnail: boolean | undefined, cancelToken?: CancelToken): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/File/GetFile?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (getThumbnail === null)
            throw new Error("The parameter 'getThumbnail' cannot be null.");
        else if (getThumbnail !== undefined)
            url_ += "getThumbnail=" + encodeURIComponent("" + getThumbnail) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            responseType: "blob",
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetFile(_response);
        });
    }

    protected processGetFile(response: AxiosResponse): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return Promise.resolve({ fileName: fileName, status: status, data: new Blob([response.data], { type: response.headers["content-type"] }), headers: _headers });
        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = NotFoundResult.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ForbidResult.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileResponse>(null as any);
    }
}

export class MessageClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    /**
     * @return OK
     */
    getAllChats( cancelToken?: CancelToken): Promise<ChatListItemDto[]> {
        let url_ = this.baseUrl + "/api/Message/GetAllChats";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllChats(_response);
        });
    }

    protected processGetAllChats(response: AxiosResponse): Promise<ChatListItemDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ChatListItemDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<ChatListItemDto[]>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RequestExceptionResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ChatListItemDto[]>(null as any);
    }

    /**
     * @param chatId (optional) 
     * @return OK
     */
    getChatMessages(chatId: number | undefined, cancelToken?: CancelToken): Promise<{ [key: string]: MessageItemDto[]; }> {
        let url_ = this.baseUrl + "/api/Message/GetChatMessages?";
        if (chatId === null)
            throw new Error("The parameter 'chatId' cannot be null.");
        else if (chatId !== undefined)
            url_ += "chatId=" + encodeURIComponent("" + chatId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetChatMessages(_response);
        });
    }

    protected processGetChatMessages(response: AxiosResponse): Promise<{ [key: string]: MessageItemDto[]; }> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (resultData200) {
                result200 = {} as any;
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        (<any>result200)![key] = resultData200[key] ? resultData200[key].map((i: any) => MessageItemDto.fromJS(i)) : [];
                }
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<{ [key: string]: MessageItemDto[]; }>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RequestExceptionResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<{ [key: string]: MessageItemDto[]; }>(null as any);
    }

    /**
     * @param userId (optional) 
     * @param advertisementId (optional) 
     * @param withMessage (optional) 
     * @return OK
     */
    createChat(userId: number | undefined, advertisementId: number | null | undefined, withMessage: SendMessageRequest | null | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/Message/CreateChat";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (userId === null || userId === undefined)
            throw new Error("The parameter 'userId' cannot be null.");
        else
            content_.append("userId", userId.toString());
        if (advertisementId !== null && advertisementId !== undefined)
            content_.append("advertisementId", advertisementId.toString());
        if (withMessage !== null && withMessage !== undefined)
        {
            if(withMessage.chatId != null)
                content_.append("withMessage.chatId", "" + withMessage.chatId)
            if(withMessage.text != null)
                content_.append("withMessage.text", "" + withMessage.text)
            if(withMessage.attachments != null)
                content_.append("withMessage.attachments", "" + withMessage.attachments)
        }

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateChat(_response);
        });
    }

    protected processCreateChat(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RequestExceptionResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param chatId (optional) 
     * @param text (optional) 
     * @param attachments (optional) 
     * @return OK
     */
    sendMessage(chatId: number | undefined, text: string | undefined, attachments: FileParameter[] | null | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/Message/SendMessage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (chatId === null || chatId === undefined)
            throw new Error("The parameter 'chatId' cannot be null.");
        else
            content_.append("chatId", chatId.toString());
        if (text === null || text === undefined)
            throw new Error("The parameter 'text' cannot be null.");
        else
            content_.append("text", text.toString());
        if (attachments !== null && attachments !== undefined)
            attachments.forEach(item_ => content_.append("attachments", item_.data, item_.fileName ? item_.fileName : "attachments") );

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSendMessage(_response);
        });
    }

    protected processSendMessage(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RequestExceptionResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param chatId (optional) 
     * @param body (optional) 
     * @return OK
     */
    markMessageAsRead(chatId: number | undefined, body: number[] | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/Message/MarkMessageAsRead?";
        if (chatId === null)
            throw new Error("The parameter 'chatId' cannot be null.");
        else if (chatId !== undefined)
            url_ += "chatId=" + encodeURIComponent("" + chatId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processMarkMessageAsRead(_response);
        });
    }

    protected processMarkMessageAsRead(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RequestExceptionResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return OK
     */
    getUnreadMessageCount( cancelToken?: CancelToken): Promise<number> {
        let url_ = this.baseUrl + "/api/Message/GetUnreadMessageCount";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetUnreadMessageCount(_response);
        });
    }

    protected processGetUnreadMessageCount(response: AxiosResponse): Promise<number> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<number>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RequestExceptionResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<number>(null as any);
    }
}

export class PaymentClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    /**
     * @param body (optional) 
     * @return OK
     */
    getUserPayments(body: PaymentDataTableQuery | undefined, cancelToken?: CancelToken): Promise<PaymentListItemDataTableQueryResponse> {
        let url_ = this.baseUrl + "/api/Payment/GetUserPayments";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetUserPayments(_response);
        });
    }

    protected processGetUserPayments(response: AxiosResponse): Promise<PaymentListItemDataTableQueryResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PaymentListItemDataTableQueryResponse.fromJS(resultData200);
            return Promise.resolve<PaymentListItemDataTableQueryResponse>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RequestExceptionResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PaymentListItemDataTableQueryResponse>(null as any);
    }

    /**
     * @param paymentId (optional) 
     * @return OK
     */
    getUserPayment(paymentId: number | undefined, cancelToken?: CancelToken): Promise<PriceInfo> {
        let url_ = this.baseUrl + "/api/Payment/GetUserPayment?";
        if (paymentId === null)
            throw new Error("The parameter 'paymentId' cannot be null.");
        else if (paymentId !== undefined)
            url_ += "paymentId=" + encodeURIComponent("" + paymentId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetUserPayment(_response);
        });
    }

    protected processGetUserPayment(response: AxiosResponse): Promise<PriceInfo> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PriceInfo.fromJS(resultData200);
            return Promise.resolve<PriceInfo>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RequestExceptionResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PriceInfo>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    calculatePrices(body: NewPaymentItem[] | undefined, cancelToken?: CancelToken): Promise<PriceInfo> {
        let url_ = this.baseUrl + "/api/Payment/CalculatePrices";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCalculatePrices(_response);
        });
    }

    protected processCalculatePrices(response: AxiosResponse): Promise<PriceInfo> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PriceInfo.fromJS(resultData200);
            return Promise.resolve<PriceInfo>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RequestExceptionResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PriceInfo>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    makePayment(body: MakePaymentRequest | undefined, cancelToken?: CancelToken): Promise<Ok> {
        let url_ = this.baseUrl + "/api/Payment/MakePayment";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processMakePayment(_response);
        });
    }

    protected processMakePayment(response: AxiosResponse): Promise<Ok> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Ok.fromJS(resultData200);
            return Promise.resolve<Ok>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RequestExceptionResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Ok>(null as any);
    }
}

export class UserClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    /**
     * @param body (optional) 
     * @return OK
     */
    login(body: LoginDto | undefined, cancelToken?: CancelToken): Promise<AccessTokenResponse> {
        let url_ = this.baseUrl + "/api/User/Login";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processLogin(_response);
        });
    }

    protected processLogin(response: AxiosResponse): Promise<AccessTokenResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = AccessTokenResponse.fromJS(resultData200);
            return Promise.resolve<AccessTokenResponse>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RequestExceptionResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<AccessTokenResponse>(null as any);
    }

    /**
     * @return OK
     */
    logout( cancelToken?: CancelToken): Promise<Ok> {
        let url_ = this.baseUrl + "/api/User/Logout";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processLogout(_response);
        });
    }

    protected processLogout(response: AxiosResponse): Promise<Ok> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Ok.fromJS(resultData200);
            return Promise.resolve<Ok>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RequestExceptionResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Ok>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    refresh(body: RefreshRequest | undefined, cancelToken?: CancelToken): Promise<AccessTokenResponse> {
        let url_ = this.baseUrl + "/api/User/Refresh";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRefresh(_response);
        });
    }

    protected processRefresh(response: AxiosResponse): Promise<AccessTokenResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = AccessTokenResponse.fromJS(resultData200);
            return Promise.resolve<AccessTokenResponse>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = UnauthorizedHttpResult.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<AccessTokenResponse>(null as any);
    }

    /**
     * @param email (optional) 
     * @param isEmailPublic (optional) 
     * @param password (optional) 
     * @param passwordConfirmation (optional) 
     * @param firstName (optional) 
     * @param lastName (optional) 
     * @param userName (optional) 
     * @param phoneNumber (optional) 
     * @param isPhoneNumberPublic (optional) 
     * @param profileImage (optional) 
     * @return OK
     */
    register(email: string | undefined, isEmailPublic: boolean | undefined, password: string | undefined, passwordConfirmation: string | undefined, firstName: string | undefined, lastName: string | undefined, userName: string | undefined, phoneNumber: string | undefined, isPhoneNumberPublic: boolean | undefined, profileImage: FileParameter | null | undefined, cancelToken?: CancelToken): Promise<OkResult> {
        let url_ = this.baseUrl + "/api/User/Register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (email === null || email === undefined)
            throw new Error("The parameter 'email' cannot be null.");
        else
            content_.append("email", email.toString());
        if (isEmailPublic === null || isEmailPublic === undefined)
            throw new Error("The parameter 'isEmailPublic' cannot be null.");
        else
            content_.append("isEmailPublic", isEmailPublic.toString());
        if (password === null || password === undefined)
            throw new Error("The parameter 'password' cannot be null.");
        else
            content_.append("password", password.toString());
        if (passwordConfirmation === null || passwordConfirmation === undefined)
            throw new Error("The parameter 'passwordConfirmation' cannot be null.");
        else
            content_.append("passwordConfirmation", passwordConfirmation.toString());
        if (firstName === null || firstName === undefined)
            throw new Error("The parameter 'firstName' cannot be null.");
        else
            content_.append("firstName", firstName.toString());
        if (lastName === null || lastName === undefined)
            throw new Error("The parameter 'lastName' cannot be null.");
        else
            content_.append("lastName", lastName.toString());
        if (userName === null || userName === undefined)
            throw new Error("The parameter 'userName' cannot be null.");
        else
            content_.append("userName", userName.toString());
        if (phoneNumber === null || phoneNumber === undefined)
            throw new Error("The parameter 'phoneNumber' cannot be null.");
        else
            content_.append("phoneNumber", phoneNumber.toString());
        if (isPhoneNumberPublic === null || isPhoneNumberPublic === undefined)
            throw new Error("The parameter 'isPhoneNumberPublic' cannot be null.");
        else
            content_.append("isPhoneNumberPublic", isPhoneNumberPublic.toString());
        if (profileImage !== null && profileImage !== undefined)
            content_.append("profileImage", profileImage.data, profileImage.fileName ? profileImage.fileName : "profileImage");

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRegister(_response);
        });
    }

    protected processRegister(response: AxiosResponse): Promise<OkResult> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = OkResult.fromJS(resultData200);
            return Promise.resolve<OkResult>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RequestExceptionResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<OkResult>(null as any);
    }

    /**
     * @param userId (optional) 
     * @return OK
     */
    getPublicUserInfo(userId: number | undefined, cancelToken?: CancelToken): Promise<PublicUserInfoDto> {
        let url_ = this.baseUrl + "/api/User/GetPublicUserInfo?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetPublicUserInfo(_response);
        });
    }

    protected processGetPublicUserInfo(response: AxiosResponse): Promise<PublicUserInfoDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PublicUserInfoDto.fromJS(resultData200);
            return Promise.resolve<PublicUserInfoDto>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RequestExceptionResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PublicUserInfoDto>(null as any);
    }

    /**
     * @return OK
     */
    getUserInfo( cancelToken?: CancelToken): Promise<UserInfo> {
        let url_ = this.baseUrl + "/api/User/GetUserInfo";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetUserInfo(_response);
        });
    }

    protected processGetUserInfo(response: AxiosResponse): Promise<UserInfo> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = UserInfo.fromJS(resultData200);
            return Promise.resolve<UserInfo>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<UserInfo>(null as any);
    }

    /**
     * @param email (optional) 
     * @param isEmailPublic (optional) 
     * @param firstName (optional) 
     * @param lastName (optional) 
     * @param userName (optional) 
     * @param phoneNumber (optional) 
     * @param isPhoneNumberPublic (optional) 
     * @param linkToUserSite (optional) 
     * @param profileImageChanged (optional) 
     * @param profileImage (optional) 
     * @return OK
     */
    updateUserInfo(email: string | undefined, isEmailPublic: boolean | undefined, firstName: string | undefined, lastName: string | undefined, userName: string | undefined, phoneNumber: string | undefined, isPhoneNumberPublic: boolean | undefined, linkToUserSite: string | null | undefined, profileImageChanged: boolean | undefined, profileImage: FileParameter | null | undefined, cancelToken?: CancelToken): Promise<OkResult> {
        let url_ = this.baseUrl + "/api/User/UpdateUserInfo";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (email === null || email === undefined)
            throw new Error("The parameter 'email' cannot be null.");
        else
            content_.append("email", email.toString());
        if (isEmailPublic === null || isEmailPublic === undefined)
            throw new Error("The parameter 'isEmailPublic' cannot be null.");
        else
            content_.append("isEmailPublic", isEmailPublic.toString());
        if (firstName === null || firstName === undefined)
            throw new Error("The parameter 'firstName' cannot be null.");
        else
            content_.append("firstName", firstName.toString());
        if (lastName === null || lastName === undefined)
            throw new Error("The parameter 'lastName' cannot be null.");
        else
            content_.append("lastName", lastName.toString());
        if (userName === null || userName === undefined)
            throw new Error("The parameter 'userName' cannot be null.");
        else
            content_.append("userName", userName.toString());
        if (phoneNumber === null || phoneNumber === undefined)
            throw new Error("The parameter 'phoneNumber' cannot be null.");
        else
            content_.append("phoneNumber", phoneNumber.toString());
        if (isPhoneNumberPublic === null || isPhoneNumberPublic === undefined)
            throw new Error("The parameter 'isPhoneNumberPublic' cannot be null.");
        else
            content_.append("isPhoneNumberPublic", isPhoneNumberPublic.toString());
        if (linkToUserSite !== null && linkToUserSite !== undefined)
            content_.append("linkToUserSite", linkToUserSite.toString());
        if (profileImageChanged === null || profileImageChanged === undefined)
            throw new Error("The parameter 'profileImageChanged' cannot be null.");
        else
            content_.append("profileImageChanged", profileImageChanged.toString());
        if (profileImage !== null && profileImage !== undefined)
            content_.append("profileImage", profileImage.data, profileImage.fileName ? profileImage.fileName : "profileImage");

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateUserInfo(_response);
        });
    }

    protected processUpdateUserInfo(response: AxiosResponse): Promise<OkResult> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = OkResult.fromJS(resultData200);
            return Promise.resolve<OkResult>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RequestExceptionResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<OkResult>(null as any);
    }

    /**
     * @return OK
     */
    getCurrentUserPermissions( cancelToken?: CancelToken): Promise<string[]> {
        let url_ = this.baseUrl + "/api/User/GetCurrentUserPermissions";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetCurrentUserPermissions(_response);
        });
    }

    protected processGetCurrentUserPermissions(response: AxiosResponse): Promise<string[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<string[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<string[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    changePassword(body: ChangePasswordRequest | undefined, cancelToken?: CancelToken): Promise<OkResult> {
        let url_ = this.baseUrl + "/api/User/ChangePassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processChangePassword(_response);
        });
    }

    protected processChangePassword(response: AxiosResponse): Promise<OkResult> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = OkResult.fromJS(resultData200);
            return Promise.resolve<OkResult>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RequestExceptionResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<OkResult>(null as any);
    }

    /**
     * @param language (optional) 
     * @return OK
     */
    setLanguage(language: string | undefined, cancelToken?: CancelToken): Promise<OkResult> {
        let url_ = this.baseUrl + "/api/User/SetLanguage?";
        if (language === null)
            throw new Error("The parameter 'language' cannot be null.");
        else if (language !== undefined)
            url_ += "language=" + encodeURIComponent("" + language) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSetLanguage(_response);
        });
    }

    protected processSetLanguage(response: AxiosResponse): Promise<OkResult> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = OkResult.fromJS(resultData200);
            return Promise.resolve<OkResult>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RequestExceptionResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<OkResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    getUserList(body: DataTableQuery | undefined, cancelToken?: CancelToken): Promise<UserListItemDataTableQueryResponse> {
        let url_ = this.baseUrl + "/api/User/GetUserList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetUserList(_response);
        });
    }

    protected processGetUserList(response: AxiosResponse): Promise<UserListItemDataTableQueryResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = UserListItemDataTableQueryResponse.fromJS(resultData200);
            return Promise.resolve<UserListItemDataTableQueryResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<UserListItemDataTableQueryResponse>(null as any);
    }
}

export class AccessTokenResponse implements IAccessTokenResponse {
    readonly tokenType?: string | undefined;
    accessToken!: string | undefined;
    expiresIn!: number;
    refreshToken!: string | undefined;

    constructor(data?: IAccessTokenResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).tokenType = _data["tokenType"];
            this.accessToken = _data["accessToken"];
            this.expiresIn = _data["expiresIn"];
            this.refreshToken = _data["refreshToken"];
        }
    }

    static fromJS(data: any): AccessTokenResponse {
        data = typeof data === 'object' ? data : {};
        let result = new AccessTokenResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tokenType"] = this.tokenType;
        data["accessToken"] = this.accessToken;
        data["expiresIn"] = this.expiresIn;
        data["refreshToken"] = this.refreshToken;
        return data;
    }
}

export interface IAccessTokenResponse {
    tokenType?: string | undefined;
    accessToken: string | undefined;
    expiresIn: number;
    refreshToken: string | undefined;
}

export class AdvertisementDto implements IAdvertisementDto {
    categoryId?: number;
    id?: number;
    title?: string | undefined;
    advertisementText?: string | undefined;
    postedDate?: Date;
    viewCount?: number;
    isBookmarked?: boolean | undefined;
    attributes?: AttributeValueItem[] | undefined;
    imageURLs?: ImageUrl[] | undefined;
    ownerId?: number;
    maskedAdvertiserPhoneNumber?: string | undefined;
    maskedAdvertiserEmail?: string | undefined;

    constructor(data?: IAdvertisementDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.categoryId = _data["categoryId"];
            this.id = _data["id"];
            this.title = _data["title"];
            this.advertisementText = _data["advertisementText"];
            this.postedDate = _data["postedDate"] ? new Date(_data["postedDate"].toString()) : <any>undefined;
            this.viewCount = _data["viewCount"];
            this.isBookmarked = _data["isBookmarked"];
            if (Array.isArray(_data["attributes"])) {
                this.attributes = [] as any;
                for (let item of _data["attributes"])
                    this.attributes!.push(AttributeValueItem.fromJS(item));
            }
            if (Array.isArray(_data["imageURLs"])) {
                this.imageURLs = [] as any;
                for (let item of _data["imageURLs"])
                    this.imageURLs!.push(ImageUrl.fromJS(item));
            }
            this.ownerId = _data["ownerId"];
            this.maskedAdvertiserPhoneNumber = _data["maskedAdvertiserPhoneNumber"];
            this.maskedAdvertiserEmail = _data["maskedAdvertiserEmail"];
        }
    }

    static fromJS(data: any): AdvertisementDto {
        data = typeof data === 'object' ? data : {};
        let result = new AdvertisementDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["categoryId"] = this.categoryId;
        data["id"] = this.id;
        data["title"] = this.title;
        data["advertisementText"] = this.advertisementText;
        data["postedDate"] = this.postedDate ? this.postedDate.toISOString() : <any>undefined;
        data["viewCount"] = this.viewCount;
        data["isBookmarked"] = this.isBookmarked;
        if (Array.isArray(this.attributes)) {
            data["attributes"] = [];
            for (let item of this.attributes)
                data["attributes"].push(item ? item.toJSON() : <any>undefined);
        }
        if (Array.isArray(this.imageURLs)) {
            data["imageURLs"] = [];
            for (let item of this.imageURLs)
                data["imageURLs"].push(item ? item.toJSON() : <any>undefined);
        }
        data["ownerId"] = this.ownerId;
        data["maskedAdvertiserPhoneNumber"] = this.maskedAdvertiserPhoneNumber;
        data["maskedAdvertiserEmail"] = this.maskedAdvertiserEmail;
        return data;
    }
}

export interface IAdvertisementDto {
    categoryId?: number;
    id?: number;
    title?: string | undefined;
    advertisementText?: string | undefined;
    postedDate?: Date;
    viewCount?: number;
    isBookmarked?: boolean | undefined;
    attributes?: AttributeValueItem[] | undefined;
    imageURLs?: ImageUrl[] | undefined;
    ownerId?: number;
    maskedAdvertiserPhoneNumber?: string | undefined;
    maskedAdvertiserEmail?: string | undefined;
}

export class AdvertisementFormInfo implements IAdvertisementFormInfo {
    advertisement?: CreateOrEditAdvertisementRequest | undefined;
    categoryInfo?: CategoryAttributeListData | undefined;

    constructor(data?: IAdvertisementFormInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.advertisement = _data["advertisement"] ? CreateOrEditAdvertisementRequest.fromJS(_data["advertisement"]) : <any>undefined;
            this.categoryInfo = _data["categoryInfo"] ? CategoryAttributeListData.fromJS(_data["categoryInfo"]) : <any>undefined;
        }
    }

    static fromJS(data: any): AdvertisementFormInfo {
        data = typeof data === 'object' ? data : {};
        let result = new AdvertisementFormInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["advertisement"] = this.advertisement ? this.advertisement.toJSON() : <any>undefined;
        data["categoryInfo"] = this.categoryInfo ? this.categoryInfo.toJSON() : <any>undefined;
        return data;
    }
}

export interface IAdvertisementFormInfo {
    advertisement?: CreateOrEditAdvertisementRequest | undefined;
    categoryInfo?: CategoryAttributeListData | undefined;
}

export class AdvertisementInfo implements IAdvertisementInfo {
    id?: number;
    title?: string | undefined;
    categoryName?: string | undefined;
    status?: PaymentSubjectStatus;
    validToDate?: Date | undefined;
    createdAtDate?: Date | undefined;

    constructor(data?: IAdvertisementInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            this.categoryName = _data["categoryName"];
            this.status = _data["status"];
            this.validToDate = _data["validToDate"] ? new Date(_data["validToDate"].toString()) : <any>undefined;
            this.createdAtDate = _data["createdAtDate"] ? new Date(_data["createdAtDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): AdvertisementInfo {
        data = typeof data === 'object' ? data : {};
        let result = new AdvertisementInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["categoryName"] = this.categoryName;
        data["status"] = this.status;
        data["validToDate"] = this.validToDate ? this.validToDate.toISOString() : <any>undefined;
        data["createdAtDate"] = this.createdAtDate ? this.createdAtDate.toISOString() : <any>undefined;
        return data;
    }
}

export interface IAdvertisementInfo {
    id?: number;
    title?: string | undefined;
    categoryName?: string | undefined;
    status?: PaymentSubjectStatus;
    validToDate?: Date | undefined;
    createdAtDate?: Date | undefined;
}

export class AdvertisementInfoDataTableQueryResponse implements IAdvertisementInfoDataTableQueryResponse {
    draw?: number;
    recordsTotal?: number;
    recordsFiltered?: number;
    data?: AdvertisementInfo[] | undefined;
    aggregates?: { [key: string]: any; } | undefined;
    error?: string | undefined;

    constructor(data?: IAdvertisementInfoDataTableQueryResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.draw = _data["draw"];
            this.recordsTotal = _data["recordsTotal"];
            this.recordsFiltered = _data["recordsFiltered"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(AdvertisementInfo.fromJS(item));
            }
            if (_data["aggregates"]) {
                this.aggregates = {} as any;
                for (let key in _data["aggregates"]) {
                    if (_data["aggregates"].hasOwnProperty(key))
                        (<any>this.aggregates)![key] = _data["aggregates"][key];
                }
            }
            this.error = _data["error"];
        }
    }

    static fromJS(data: any): AdvertisementInfoDataTableQueryResponse {
        data = typeof data === 'object' ? data : {};
        let result = new AdvertisementInfoDataTableQueryResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["draw"] = this.draw;
        data["recordsTotal"] = this.recordsTotal;
        data["recordsFiltered"] = this.recordsFiltered;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item ? item.toJSON() : <any>undefined);
        }
        if (this.aggregates) {
            data["aggregates"] = {};
            for (let key in this.aggregates) {
                if (this.aggregates.hasOwnProperty(key))
                    (<any>data["aggregates"])[key] = (<any>this.aggregates)[key];
            }
        }
        data["error"] = this.error;
        return data;
    }
}

export interface IAdvertisementInfoDataTableQueryResponse {
    draw?: number;
    recordsTotal?: number;
    recordsFiltered?: number;
    data?: AdvertisementInfo[] | undefined;
    aggregates?: { [key: string]: any; } | undefined;
    error?: string | undefined;
}

export class AdvertisementListItem implements IAdvertisementListItem {
    id?: number;
    categoryId?: number;
    categoryName?: string | undefined;
    createdDate?: Date;
    title?: string | undefined;
    advertisementText?: string | undefined;
    thumbnailImageUrl?: string | undefined;
    attributeValues?: AttributeValueItem[] | undefined;

    constructor(data?: IAdvertisementListItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.categoryId = _data["categoryId"];
            this.categoryName = _data["categoryName"];
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.title = _data["title"];
            this.advertisementText = _data["advertisementText"];
            this.thumbnailImageUrl = _data["thumbnailImageUrl"];
            if (Array.isArray(_data["attributeValues"])) {
                this.attributeValues = [] as any;
                for (let item of _data["attributeValues"])
                    this.attributeValues!.push(AttributeValueItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AdvertisementListItem {
        data = typeof data === 'object' ? data : {};
        let result = new AdvertisementListItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["categoryId"] = this.categoryId;
        data["categoryName"] = this.categoryName;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["title"] = this.title;
        data["advertisementText"] = this.advertisementText;
        data["thumbnailImageUrl"] = this.thumbnailImageUrl;
        if (Array.isArray(this.attributeValues)) {
            data["attributeValues"] = [];
            for (let item of this.attributeValues)
                data["attributeValues"].push(item ? item.toJSON() : <any>undefined);
        }
        return data;
    }
}

export interface IAdvertisementListItem {
    id?: number;
    categoryId?: number;
    categoryName?: string | undefined;
    createdDate?: Date;
    title?: string | undefined;
    advertisementText?: string | undefined;
    thumbnailImageUrl?: string | undefined;
    attributeValues?: AttributeValueItem[] | undefined;
}

export class AdvertisementListItemDataTableQueryResponse implements IAdvertisementListItemDataTableQueryResponse {
    draw?: number;
    recordsTotal?: number;
    recordsFiltered?: number;
    data?: AdvertisementListItem[] | undefined;
    aggregates?: { [key: string]: any; } | undefined;
    error?: string | undefined;

    constructor(data?: IAdvertisementListItemDataTableQueryResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.draw = _data["draw"];
            this.recordsTotal = _data["recordsTotal"];
            this.recordsFiltered = _data["recordsFiltered"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(AdvertisementListItem.fromJS(item));
            }
            if (_data["aggregates"]) {
                this.aggregates = {} as any;
                for (let key in _data["aggregates"]) {
                    if (_data["aggregates"].hasOwnProperty(key))
                        (<any>this.aggregates)![key] = _data["aggregates"][key];
                }
            }
            this.error = _data["error"];
        }
    }

    static fromJS(data: any): AdvertisementListItemDataTableQueryResponse {
        data = typeof data === 'object' ? data : {};
        let result = new AdvertisementListItemDataTableQueryResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["draw"] = this.draw;
        data["recordsTotal"] = this.recordsTotal;
        data["recordsFiltered"] = this.recordsFiltered;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item ? item.toJSON() : <any>undefined);
        }
        if (this.aggregates) {
            data["aggregates"] = {};
            for (let key in this.aggregates) {
                if (this.aggregates.hasOwnProperty(key))
                    (<any>data["aggregates"])[key] = (<any>this.aggregates)[key];
            }
        }
        data["error"] = this.error;
        return data;
    }
}

export interface IAdvertisementListItemDataTableQueryResponse {
    draw?: number;
    recordsTotal?: number;
    recordsFiltered?: number;
    data?: AdvertisementListItem[] | undefined;
    aggregates?: { [key: string]: any; } | undefined;
    error?: string | undefined;
}

export class AdvertisementQuery implements IAdvertisementQuery {
    start?: number | undefined;
    length?: number | undefined;
    search?: SearchQuery | undefined;
    order?: OrderQuery[] | undefined;
    columns?: TableColumn[] | undefined;
    categoryId?: number | undefined;
    advertisementOwnerId?: number | undefined;
    advertisementIds?: number[] | undefined;
    attributeSearch?: AttributeSearchQuery[] | undefined;
    attributeOrder?: AttributeOrderQuery[] | undefined;

    constructor(data?: IAdvertisementQuery) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.start = _data["start"];
            this.length = _data["length"];
            this.search = _data["search"] ? SearchQuery.fromJS(_data["search"]) : <any>undefined;
            if (Array.isArray(_data["order"])) {
                this.order = [] as any;
                for (let item of _data["order"])
                    this.order!.push(OrderQuery.fromJS(item));
            }
            if (Array.isArray(_data["columns"])) {
                this.columns = [] as any;
                for (let item of _data["columns"])
                    this.columns!.push(TableColumn.fromJS(item));
            }
            this.categoryId = _data["categoryId"];
            this.advertisementOwnerId = _data["advertisementOwnerId"];
            if (Array.isArray(_data["advertisementIds"])) {
                this.advertisementIds = [] as any;
                for (let item of _data["advertisementIds"])
                    this.advertisementIds!.push(item);
            }
            if (Array.isArray(_data["attributeSearch"])) {
                this.attributeSearch = [] as any;
                for (let item of _data["attributeSearch"])
                    this.attributeSearch!.push(AttributeSearchQuery.fromJS(item));
            }
            if (Array.isArray(_data["attributeOrder"])) {
                this.attributeOrder = [] as any;
                for (let item of _data["attributeOrder"])
                    this.attributeOrder!.push(AttributeOrderQuery.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AdvertisementQuery {
        data = typeof data === 'object' ? data : {};
        let result = new AdvertisementQuery();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["start"] = this.start;
        data["length"] = this.length;
        data["search"] = this.search ? this.search.toJSON() : <any>undefined;
        if (Array.isArray(this.order)) {
            data["order"] = [];
            for (let item of this.order)
                data["order"].push(item ? item.toJSON() : <any>undefined);
        }
        if (Array.isArray(this.columns)) {
            data["columns"] = [];
            for (let item of this.columns)
                data["columns"].push(item ? item.toJSON() : <any>undefined);
        }
        data["categoryId"] = this.categoryId;
        data["advertisementOwnerId"] = this.advertisementOwnerId;
        if (Array.isArray(this.advertisementIds)) {
            data["advertisementIds"] = [];
            for (let item of this.advertisementIds)
                data["advertisementIds"].push(item);
        }
        if (Array.isArray(this.attributeSearch)) {
            data["attributeSearch"] = [];
            for (let item of this.attributeSearch)
                data["attributeSearch"].push(item ? item.toJSON() : <any>undefined);
        }
        if (Array.isArray(this.attributeOrder)) {
            data["attributeOrder"] = [];
            for (let item of this.attributeOrder)
                data["attributeOrder"].push(item ? item.toJSON() : <any>undefined);
        }
        return data;
    }
}

export interface IAdvertisementQuery {
    start?: number | undefined;
    length?: number | undefined;
    search?: SearchQuery | undefined;
    order?: OrderQuery[] | undefined;
    columns?: TableColumn[] | undefined;
    categoryId?: number | undefined;
    advertisementOwnerId?: number | undefined;
    advertisementIds?: number[] | undefined;
    attributeSearch?: AttributeSearchQuery[] | undefined;
    attributeOrder?: AttributeOrderQuery[] | undefined;
}

export class AttributeFormInfo implements IAttributeFormInfo {
    id?: number;
    name?: string | undefined;
    order?: number;
    valueValidationRegex?: string | undefined;
    valueListId?: number | undefined;
    iconName?: string | undefined;
    attributeValueType?: ValueTypes;

    constructor(data?: IAttributeFormInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.order = _data["order"];
            this.valueValidationRegex = _data["valueValidationRegex"];
            this.valueListId = _data["valueListId"];
            this.iconName = _data["iconName"];
            this.attributeValueType = _data["attributeValueType"];
        }
    }

    static fromJS(data: any): AttributeFormInfo {
        data = typeof data === 'object' ? data : {};
        let result = new AttributeFormInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["order"] = this.order;
        data["valueValidationRegex"] = this.valueValidationRegex;
        data["valueListId"] = this.valueListId;
        data["iconName"] = this.iconName;
        data["attributeValueType"] = this.attributeValueType;
        return data;
    }
}

export interface IAttributeFormInfo {
    id?: number;
    name?: string | undefined;
    order?: number;
    valueValidationRegex?: string | undefined;
    valueListId?: number | undefined;
    iconName?: string | undefined;
    attributeValueType?: ValueTypes;
}

export class AttributeOrderQuery implements IAttributeOrderQuery {
    attributeId!: number;
    direction!: string;

    constructor(data?: IAttributeOrderQuery) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.attributeId = _data["attributeId"];
            this.direction = _data["direction"];
        }
    }

    static fromJS(data: any): AttributeOrderQuery {
        data = typeof data === 'object' ? data : {};
        let result = new AttributeOrderQuery();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["attributeId"] = this.attributeId;
        data["direction"] = this.direction;
        return data;
    }
}

export interface IAttributeOrderQuery {
    attributeId: number;
    direction: string;
}

export class AttributeSearchQuery implements IAttributeSearchQuery {
    attributeId!: number;
    value?: string | undefined;
    secondaryValue?: string | undefined;

    constructor(data?: IAttributeSearchQuery) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.attributeId = _data["attributeId"];
            this.value = _data["value"];
            this.secondaryValue = _data["secondaryValue"];
        }
    }

    static fromJS(data: any): AttributeSearchQuery {
        data = typeof data === 'object' ? data : {};
        let result = new AttributeSearchQuery();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["attributeId"] = this.attributeId;
        data["value"] = this.value;
        data["secondaryValue"] = this.secondaryValue;
        return data;
    }
}

export interface IAttributeSearchQuery {
    attributeId: number;
    value?: string | undefined;
    secondaryValue?: string | undefined;
}

export class AttributeValueItem implements IAttributeValueItem {
    attributeId?: number;
    attributeName?: string | undefined;
    value?: string | undefined;
    valueName?: string | undefined;
    iconName?: string | undefined;

    constructor(data?: IAttributeValueItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.attributeId = _data["attributeId"];
            this.attributeName = _data["attributeName"];
            this.value = _data["value"];
            this.valueName = _data["valueName"];
            this.iconName = _data["iconName"];
        }
    }

    static fromJS(data: any): AttributeValueItem {
        data = typeof data === 'object' ? data : {};
        let result = new AttributeValueItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["attributeId"] = this.attributeId;
        data["attributeName"] = this.attributeName;
        data["value"] = this.value;
        data["valueName"] = this.valueName;
        data["iconName"] = this.iconName;
        return data;
    }
}

export interface IAttributeValueItem {
    attributeId?: number;
    attributeName?: string | undefined;
    value?: string | undefined;
    valueName?: string | undefined;
    iconName?: string | undefined;
}

export class AttributeValueListEntryItem implements IAttributeValueListEntryItem {
    id?: number;
    name?: string | undefined;
    orderIndex?: number;

    constructor(data?: IAttributeValueListEntryItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.orderIndex = _data["orderIndex"];
        }
    }

    static fromJS(data: any): AttributeValueListEntryItem {
        data = typeof data === 'object' ? data : {};
        let result = new AttributeValueListEntryItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["orderIndex"] = this.orderIndex;
        return data;
    }
}

export interface IAttributeValueListEntryItem {
    id?: number;
    name?: string | undefined;
    orderIndex?: number;
}

export class AttributeValueListItem implements IAttributeValueListItem {
    id?: number;
    name?: string | undefined;
    entries?: AttributeValueListEntryItem[] | undefined;

    constructor(data?: IAttributeValueListItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            if (Array.isArray(_data["entries"])) {
                this.entries = [] as any;
                for (let item of _data["entries"])
                    this.entries!.push(AttributeValueListEntryItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AttributeValueListItem {
        data = typeof data === 'object' ? data : {};
        let result = new AttributeValueListItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        if (Array.isArray(this.entries)) {
            data["entries"] = [];
            for (let item of this.entries)
                data["entries"].push(item ? item.toJSON() : <any>undefined);
        }
        return data;
    }
}

export interface IAttributeValueListItem {
    id?: number;
    name?: string | undefined;
    entries?: AttributeValueListEntryItem[] | undefined;
}

export class AuthenticationProperties implements IAuthenticationProperties {
    items?: { [key: string]: string; } | undefined;

    constructor(data?: IAuthenticationProperties) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["items"]) {
                this.items = {} as any;
                for (let key in _data["items"]) {
                    if (_data["items"].hasOwnProperty(key))
                        (<any>this.items)![key] = _data["items"][key];
                }
            }
        }
    }

    static fromJS(data: any): AuthenticationProperties {
        data = typeof data === 'object' ? data : {};
        let result = new AuthenticationProperties();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items) {
            data["items"] = {};
            for (let key in this.items) {
                if (this.items.hasOwnProperty(key))
                    (<any>data["items"])[key] = (<any>this.items)[key];
            }
        }
        return data;
    }
}

export interface IAuthenticationProperties {
    items?: { [key: string]: string; } | undefined;
}

export class BookmarkAdvertisementRequest implements IBookmarkAdvertisementRequest {
    advertisementId!: number;
    addBookmark!: boolean;

    constructor(data?: IBookmarkAdvertisementRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.advertisementId = _data["advertisementId"];
            this.addBookmark = _data["addBookmark"];
        }
    }

    static fromJS(data: any): BookmarkAdvertisementRequest {
        data = typeof data === 'object' ? data : {};
        let result = new BookmarkAdvertisementRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["advertisementId"] = this.advertisementId;
        data["addBookmark"] = this.addBookmark;
        return data;
    }
}

export interface IBookmarkAdvertisementRequest {
    advertisementId: number;
    addBookmark: boolean;
}

export class CategoryAttributeInfo implements ICategoryAttributeInfo {
    id?: number;
    name?: string | undefined;
    sortable?: boolean;
    searchable?: boolean;
    order?: number;
    valueListId?: number | undefined;
    iconName?: string | undefined;
    attributeValueType?: ValueTypes;
    attributeFilterType?: FilterType;

    constructor(data?: ICategoryAttributeInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.sortable = _data["sortable"];
            this.searchable = _data["searchable"];
            this.order = _data["order"];
            this.valueListId = _data["valueListId"];
            this.iconName = _data["iconName"];
            this.attributeValueType = _data["attributeValueType"];
            this.attributeFilterType = _data["attributeFilterType"];
        }
    }

    static fromJS(data: any): CategoryAttributeInfo {
        data = typeof data === 'object' ? data : {};
        let result = new CategoryAttributeInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["sortable"] = this.sortable;
        data["searchable"] = this.searchable;
        data["order"] = this.order;
        data["valueListId"] = this.valueListId;
        data["iconName"] = this.iconName;
        data["attributeValueType"] = this.attributeValueType;
        data["attributeFilterType"] = this.attributeFilterType;
        return data;
    }
}

export interface ICategoryAttributeInfo {
    id?: number;
    name?: string | undefined;
    sortable?: boolean;
    searchable?: boolean;
    order?: number;
    valueListId?: number | undefined;
    iconName?: string | undefined;
    attributeValueType?: ValueTypes;
    attributeFilterType?: FilterType;
}

export class CategoryAttributeListData implements ICategoryAttributeListData {
    attributeInfo?: AttributeFormInfo[] | undefined;
    attributeValueLists?: AttributeValueListItem[] | undefined;

    constructor(data?: ICategoryAttributeListData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["attributeInfo"])) {
                this.attributeInfo = [] as any;
                for (let item of _data["attributeInfo"])
                    this.attributeInfo!.push(AttributeFormInfo.fromJS(item));
            }
            if (Array.isArray(_data["attributeValueLists"])) {
                this.attributeValueLists = [] as any;
                for (let item of _data["attributeValueLists"])
                    this.attributeValueLists!.push(AttributeValueListItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CategoryAttributeListData {
        data = typeof data === 'object' ? data : {};
        let result = new CategoryAttributeListData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.attributeInfo)) {
            data["attributeInfo"] = [];
            for (let item of this.attributeInfo)
                data["attributeInfo"].push(item ? item.toJSON() : <any>undefined);
        }
        if (Array.isArray(this.attributeValueLists)) {
            data["attributeValueLists"] = [];
            for (let item of this.attributeValueLists)
                data["attributeValueLists"].push(item ? item.toJSON() : <any>undefined);
        }
        return data;
    }
}

export interface ICategoryAttributeListData {
    attributeInfo?: AttributeFormInfo[] | undefined;
    attributeValueLists?: AttributeValueListItem[] | undefined;
}

export class CategoryInfo implements ICategoryInfo {
    categoryName?: string | undefined;
    attributeInfo?: CategoryAttributeInfo[] | undefined;
    attributeValueLists?: AttributeValueListItem[] | undefined;

    constructor(data?: ICategoryInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.categoryName = _data["categoryName"];
            if (Array.isArray(_data["attributeInfo"])) {
                this.attributeInfo = [] as any;
                for (let item of _data["attributeInfo"])
                    this.attributeInfo!.push(CategoryAttributeInfo.fromJS(item));
            }
            if (Array.isArray(_data["attributeValueLists"])) {
                this.attributeValueLists = [] as any;
                for (let item of _data["attributeValueLists"])
                    this.attributeValueLists!.push(AttributeValueListItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CategoryInfo {
        data = typeof data === 'object' ? data : {};
        let result = new CategoryInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["categoryName"] = this.categoryName;
        if (Array.isArray(this.attributeInfo)) {
            data["attributeInfo"] = [];
            for (let item of this.attributeInfo)
                data["attributeInfo"].push(item ? item.toJSON() : <any>undefined);
        }
        if (Array.isArray(this.attributeValueLists)) {
            data["attributeValueLists"] = [];
            for (let item of this.attributeValueLists)
                data["attributeValueLists"].push(item ? item.toJSON() : <any>undefined);
        }
        return data;
    }
}

export interface ICategoryInfo {
    categoryName?: string | undefined;
    attributeInfo?: CategoryAttributeInfo[] | undefined;
    attributeValueLists?: AttributeValueListItem[] | undefined;
}

export class CategoryItem implements ICategoryItem {
    id?: number;
    name?: string | undefined;
    canContainAdvertisements?: boolean;
    parentCategoryId?: number | undefined;
    advertisementCount?: number | undefined;

    constructor(data?: ICategoryItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.canContainAdvertisements = _data["canContainAdvertisements"];
            this.parentCategoryId = _data["parentCategoryId"];
            this.advertisementCount = _data["advertisementCount"];
        }
    }

    static fromJS(data: any): CategoryItem {
        data = typeof data === 'object' ? data : {};
        let result = new CategoryItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["canContainAdvertisements"] = this.canContainAdvertisements;
        data["parentCategoryId"] = this.parentCategoryId;
        data["advertisementCount"] = this.advertisementCount;
        return data;
    }
}

export interface ICategoryItem {
    id?: number;
    name?: string | undefined;
    canContainAdvertisements?: boolean;
    parentCategoryId?: number | undefined;
    advertisementCount?: number | undefined;
}

export class ChangePasswordRequest implements IChangePasswordRequest {
    currentPassword!: string;
    password!: string;
    confirmPassword!: string;

    constructor(data?: IChangePasswordRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.currentPassword = _data["currentPassword"];
            this.password = _data["password"];
            this.confirmPassword = _data["confirmPassword"];
        }
    }

    static fromJS(data: any): ChangePasswordRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ChangePasswordRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["currentPassword"] = this.currentPassword;
        data["password"] = this.password;
        data["confirmPassword"] = this.confirmPassword;
        return data;
    }
}

export interface IChangePasswordRequest {
    currentPassword: string;
    password: string;
    confirmPassword: string;
}

export class ChatListItemDto implements IChatListItemDto {
    id?: number;
    advertisementId?: number | undefined;
    advertisementOwnerId?: number | undefined;
    title?: string | undefined;
    lastMessage?: string | undefined;
    unreadMessageCount?: number;
    thumbnailImageUrl?: string | undefined;

    constructor(data?: IChatListItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.advertisementId = _data["advertisementId"];
            this.advertisementOwnerId = _data["advertisementOwnerId"];
            this.title = _data["title"];
            this.lastMessage = _data["lastMessage"];
            this.unreadMessageCount = _data["unreadMessageCount"];
            this.thumbnailImageUrl = _data["thumbnailImageUrl"];
        }
    }

    static fromJS(data: any): ChatListItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new ChatListItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["advertisementId"] = this.advertisementId;
        data["advertisementOwnerId"] = this.advertisementOwnerId;
        data["title"] = this.title;
        data["lastMessage"] = this.lastMessage;
        data["unreadMessageCount"] = this.unreadMessageCount;
        data["thumbnailImageUrl"] = this.thumbnailImageUrl;
        return data;
    }
}

export interface IChatListItemDto {
    id?: number;
    advertisementId?: number | undefined;
    advertisementOwnerId?: number | undefined;
    title?: string | undefined;
    lastMessage?: string | undefined;
    unreadMessageCount?: number;
    thumbnailImageUrl?: string | undefined;
}

export class CreateChatRequest implements ICreateChatRequest {
    userId?: number;
    advertisementId?: number | undefined;
    withMessage?: SendMessageRequest | undefined;

    constructor(data?: ICreateChatRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.advertisementId = _data["advertisementId"];
            this.withMessage = _data["withMessage"] ? SendMessageRequest.fromJS(_data["withMessage"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CreateChatRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreateChatRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["advertisementId"] = this.advertisementId;
        data["withMessage"] = this.withMessage ? this.withMessage.toJSON() : <any>undefined;
        return data;
    }
}

export interface ICreateChatRequest {
    userId?: number;
    advertisementId?: number | undefined;
    withMessage?: SendMessageRequest | undefined;
}

export class CreateOrEditAdvertisementRequest implements ICreateOrEditAdvertisementRequest {
    id?: number | undefined;
    categoryId!: number;
    attributeValues?: Int32StringKeyValuePair[] | undefined;
    postTime?: PostTimeDto | undefined;
    validToDate?: Date | undefined;
    title!: string;
    description!: string;
    imagesToAdd?: any[] | undefined;
    imageOrder?: ImageDto[] | undefined;

    constructor(data?: ICreateOrEditAdvertisementRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.categoryId = _data["categoryId"];
            if (Array.isArray(_data["attributeValues"])) {
                this.attributeValues = [] as any;
                for (let item of _data["attributeValues"])
                    this.attributeValues!.push(Int32StringKeyValuePair.fromJS(item));
            }
            this.postTime = _data["postTime"] ? PostTimeDto.fromJS(_data["postTime"]) : <any>undefined;
            this.validToDate = _data["validToDate"] ? new Date(_data["validToDate"].toString()) : <any>undefined;
            this.title = _data["title"];
            this.description = _data["description"];
            if (Array.isArray(_data["imagesToAdd"])) {
                this.imagesToAdd = [] as any;
                for (let item of _data["imagesToAdd"])
                    this.imagesToAdd!.push(item);
            }
            if (Array.isArray(_data["imageOrder"])) {
                this.imageOrder = [] as any;
                for (let item of _data["imageOrder"])
                    this.imageOrder!.push(ImageDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateOrEditAdvertisementRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditAdvertisementRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["categoryId"] = this.categoryId;
        if (Array.isArray(this.attributeValues)) {
            data["attributeValues"] = [];
            for (let item of this.attributeValues)
                data["attributeValues"].push(item ? item.toJSON() : <any>undefined);
        }
        data["postTime"] = this.postTime ? this.postTime.toJSON() : <any>undefined;
        data["validToDate"] = this.validToDate ? this.validToDate.toISOString() : <any>undefined;
        data["title"] = this.title;
        data["description"] = this.description;
        if (Array.isArray(this.imagesToAdd)) {
            data["imagesToAdd"] = [];
            for (let item of this.imagesToAdd)
                data["imagesToAdd"].push(item);
        }
        if (Array.isArray(this.imageOrder)) {
            data["imageOrder"] = [];
            for (let item of this.imageOrder)
                data["imageOrder"].push(item ? item.toJSON() : <any>undefined);
        }
        return data;
    }
}

export interface ICreateOrEditAdvertisementRequest {
    id?: number | undefined;
    categoryId: number;
    attributeValues?: Int32StringKeyValuePair[] | undefined;
    postTime?: PostTimeDto | undefined;
    validToDate?: Date | undefined;
    title: string;
    description: string;
    imagesToAdd?: any[] | undefined;
    imageOrder?: ImageDto[] | undefined;
}

export class CreateOrEditNotificationSubscriptionRequest implements ICreateOrEditNotificationSubscriptionRequest {
    id?: number | undefined;
    title!: string;
    keywords?: string[] | undefined;
    paidTime?: PostTimeDto | undefined;
    categoryId!: number;
    validToDate?: Date | undefined;
    attributeValues?: Int32StringKeyValuePair[] | undefined;

    constructor(data?: ICreateOrEditNotificationSubscriptionRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            if (Array.isArray(_data["keywords"])) {
                this.keywords = [] as any;
                for (let item of _data["keywords"])
                    this.keywords!.push(item);
            }
            this.paidTime = _data["paidTime"] ? PostTimeDto.fromJS(_data["paidTime"]) : <any>undefined;
            this.categoryId = _data["categoryId"];
            this.validToDate = _data["validToDate"] ? new Date(_data["validToDate"].toString()) : <any>undefined;
            if (Array.isArray(_data["attributeValues"])) {
                this.attributeValues = [] as any;
                for (let item of _data["attributeValues"])
                    this.attributeValues!.push(Int32StringKeyValuePair.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateOrEditNotificationSubscriptionRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditNotificationSubscriptionRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        if (Array.isArray(this.keywords)) {
            data["keywords"] = [];
            for (let item of this.keywords)
                data["keywords"].push(item);
        }
        data["paidTime"] = this.paidTime ? this.paidTime.toJSON() : <any>undefined;
        data["categoryId"] = this.categoryId;
        data["validToDate"] = this.validToDate ? this.validToDate.toISOString() : <any>undefined;
        if (Array.isArray(this.attributeValues)) {
            data["attributeValues"] = [];
            for (let item of this.attributeValues)
                data["attributeValues"].push(item ? item.toJSON() : <any>undefined);
        }
        return data;
    }
}

export interface ICreateOrEditNotificationSubscriptionRequest {
    id?: number | undefined;
    title: string;
    keywords?: string[] | undefined;
    paidTime?: PostTimeDto | undefined;
    categoryId: number;
    validToDate?: Date | undefined;
    attributeValues?: Int32StringKeyValuePair[] | undefined;
}

export class DataTableQuery implements IDataTableQuery {
    start?: number | undefined;
    length?: number | undefined;
    search?: SearchQuery | undefined;
    order?: OrderQuery[] | undefined;
    columns?: TableColumn[] | undefined;

    constructor(data?: IDataTableQuery) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.start = _data["start"];
            this.length = _data["length"];
            this.search = _data["search"] ? SearchQuery.fromJS(_data["search"]) : <any>undefined;
            if (Array.isArray(_data["order"])) {
                this.order = [] as any;
                for (let item of _data["order"])
                    this.order!.push(OrderQuery.fromJS(item));
            }
            if (Array.isArray(_data["columns"])) {
                this.columns = [] as any;
                for (let item of _data["columns"])
                    this.columns!.push(TableColumn.fromJS(item));
            }
        }
    }

    static fromJS(data: any): DataTableQuery {
        data = typeof data === 'object' ? data : {};
        let result = new DataTableQuery();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["start"] = this.start;
        data["length"] = this.length;
        data["search"] = this.search ? this.search.toJSON() : <any>undefined;
        if (Array.isArray(this.order)) {
            data["order"] = [];
            for (let item of this.order)
                data["order"].push(item ? item.toJSON() : <any>undefined);
        }
        if (Array.isArray(this.columns)) {
            data["columns"] = [];
            for (let item of this.columns)
                data["columns"].push(item ? item.toJSON() : <any>undefined);
        }
        return data;
    }
}

export interface IDataTableQuery {
    start?: number | undefined;
    length?: number | undefined;
    search?: SearchQuery | undefined;
    order?: OrderQuery[] | undefined;
    columns?: TableColumn[] | undefined;
}

export class DataTableQueryResponse_1 implements IDataTableQueryResponse_1 {
    draw?: number;
    recordsTotal?: number;
    recordsFiltered?: number;
    data?: T[] | undefined;
    aggregates?: { [key: string]: any; } | undefined;
    error?: string | undefined;

    constructor(data?: IDataTableQueryResponse_1) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.draw = _data["draw"];
            this.recordsTotal = _data["recordsTotal"];
            this.recordsFiltered = _data["recordsFiltered"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(T.fromJS(item));
            }
            if (_data["aggregates"]) {
                this.aggregates = {} as any;
                for (let key in _data["aggregates"]) {
                    if (_data["aggregates"].hasOwnProperty(key))
                        (<any>this.aggregates)![key] = _data["aggregates"][key];
                }
            }
            this.error = _data["error"];
        }
    }

    static fromJS(data: any): DataTableQueryResponse_1 {
        data = typeof data === 'object' ? data : {};
        let result = new DataTableQueryResponse_1();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["draw"] = this.draw;
        data["recordsTotal"] = this.recordsTotal;
        data["recordsFiltered"] = this.recordsFiltered;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item ? item.toJSON() : <any>undefined);
        }
        if (this.aggregates) {
            data["aggregates"] = {};
            for (let key in this.aggregates) {
                if (this.aggregates.hasOwnProperty(key))
                    (<any>data["aggregates"])[key] = (<any>this.aggregates)[key];
            }
        }
        data["error"] = this.error;
        return data;
    }
}

export interface IDataTableQueryResponse_1 {
    draw?: number;
    recordsTotal?: number;
    recordsFiltered?: number;
    data?: T[] | undefined;
    aggregates?: { [key: string]: any; } | undefined;
    error?: string | undefined;
}

export class EditUserInfo implements IEditUserInfo {
    email!: string;
    isEmailPublic?: boolean;
    firstName!: string;
    lastName!: string;
    userName!: string;
    phoneNumber!: string;
    isPhoneNumberPublic?: boolean;
    linkToUserSite?: string | undefined;
    profileImageChanged?: boolean;
    profileImage?: any | undefined;

    constructor(data?: IEditUserInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.isEmailPublic = _data["isEmailPublic"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.userName = _data["userName"];
            this.phoneNumber = _data["phoneNumber"];
            this.isPhoneNumberPublic = _data["isPhoneNumberPublic"];
            this.linkToUserSite = _data["linkToUserSite"];
            this.profileImageChanged = _data["profileImageChanged"];
            this.profileImage = _data["profileImage"];
        }
    }

    static fromJS(data: any): EditUserInfo {
        data = typeof data === 'object' ? data : {};
        let result = new EditUserInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["isEmailPublic"] = this.isEmailPublic;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["userName"] = this.userName;
        data["phoneNumber"] = this.phoneNumber;
        data["isPhoneNumberPublic"] = this.isPhoneNumberPublic;
        data["linkToUserSite"] = this.linkToUserSite;
        data["profileImageChanged"] = this.profileImageChanged;
        data["profileImage"] = this.profileImage;
        return data;
    }
}

export interface IEditUserInfo {
    email: string;
    isEmailPublic?: boolean;
    firstName: string;
    lastName: string;
    userName: string;
    phoneNumber: string;
    isPhoneNumberPublic?: boolean;
    linkToUserSite?: string | undefined;
    profileImageChanged?: boolean;
    profileImage?: any | undefined;
}

export enum FilterType {
    Search = "Search",
    FromTo = "FromTo",
    Match = "Match",
}

export class ForbidResult implements IForbidResult {
    authenticationSchemes?: string[] | undefined;
    properties?: AuthenticationProperties | undefined;

    constructor(data?: IForbidResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["authenticationSchemes"])) {
                this.authenticationSchemes = [] as any;
                for (let item of _data["authenticationSchemes"])
                    this.authenticationSchemes!.push(item);
            }
            this.properties = _data["properties"] ? AuthenticationProperties.fromJS(_data["properties"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ForbidResult {
        data = typeof data === 'object' ? data : {};
        let result = new ForbidResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.authenticationSchemes)) {
            data["authenticationSchemes"] = [];
            for (let item of this.authenticationSchemes)
                data["authenticationSchemes"].push(item);
        }
        data["properties"] = this.properties ? this.properties.toJSON() : <any>undefined;
        return data;
    }
}

export interface IForbidResult {
    authenticationSchemes?: string[] | undefined;
    properties?: AuthenticationProperties | undefined;
}

export class ImageDto implements IImageDto {
    id?: number;
    imageURLs?: ImageUrl | undefined;
    hash?: string | undefined;

    constructor(data?: IImageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.imageURLs = _data["imageURLs"] ? ImageUrl.fromJS(_data["imageURLs"]) : <any>undefined;
            this.hash = _data["hash"];
        }
    }

    static fromJS(data: any): ImageDto {
        data = typeof data === 'object' ? data : {};
        let result = new ImageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["imageURLs"] = this.imageURLs ? this.imageURLs.toJSON() : <any>undefined;
        data["hash"] = this.hash;
        return data;
    }
}

export interface IImageDto {
    id?: number;
    imageURLs?: ImageUrl | undefined;
    hash?: string | undefined;
}

export class ImageUrl implements IImageUrl {
    url?: string | undefined;
    thumbnailUrl?: string | undefined;

    constructor(data?: IImageUrl) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.url = _data["url"];
            this.thumbnailUrl = _data["thumbnailUrl"];
        }
    }

    static fromJS(data: any): ImageUrl {
        data = typeof data === 'object' ? data : {};
        let result = new ImageUrl();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["url"] = this.url;
        data["thumbnailUrl"] = this.thumbnailUrl;
        return data;
    }
}

export interface IImageUrl {
    url?: string | undefined;
    thumbnailUrl?: string | undefined;
}

export class Int32StringKeyValuePair implements IInt32StringKeyValuePair {
    key?: number;
    value?: string | undefined;

    constructor(data?: IInt32StringKeyValuePair) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.key = _data["key"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): Int32StringKeyValuePair {
        data = typeof data === 'object' ? data : {};
        let result = new Int32StringKeyValuePair();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        data["value"] = this.value;
        return data;
    }
}

export interface IInt32StringKeyValuePair {
    key?: number;
    value?: string | undefined;
}

export class LoginDto implements ILoginDto {
    email!: string;
    password!: string;

    constructor(data?: ILoginDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): LoginDto {
        data = typeof data === 'object' ? data : {};
        let result = new LoginDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["password"] = this.password;
        return data;
    }
}

export interface ILoginDto {
    email: string;
    password: string;
}

export class MakePaymentRequest implements IMakePaymentRequest {
    paymentItems!: NewPaymentItem[];
    totalAmountConfirmation!: number;

    constructor(data?: IMakePaymentRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.paymentItems = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["paymentItems"])) {
                this.paymentItems = [] as any;
                for (let item of _data["paymentItems"])
                    this.paymentItems!.push(NewPaymentItem.fromJS(item));
            }
            this.totalAmountConfirmation = _data["totalAmountConfirmation"];
        }
    }

    static fromJS(data: any): MakePaymentRequest {
        data = typeof data === 'object' ? data : {};
        let result = new MakePaymentRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.paymentItems)) {
            data["paymentItems"] = [];
            for (let item of this.paymentItems)
                data["paymentItems"].push(item ? item.toJSON() : <any>undefined);
        }
        data["totalAmountConfirmation"] = this.totalAmountConfirmation;
        return data;
    }
}

export interface IMakePaymentRequest {
    paymentItems: NewPaymentItem[];
    totalAmountConfirmation: number;
}

export class MessageAttachmentItemDto implements IMessageAttachmentItemDto {
    url?: string | undefined;
    fileName?: string | undefined;
    sizeInBytes?: number;

    constructor(data?: IMessageAttachmentItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.url = _data["url"];
            this.fileName = _data["fileName"];
            this.sizeInBytes = _data["sizeInBytes"];
        }
    }

    static fromJS(data: any): MessageAttachmentItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new MessageAttachmentItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["url"] = this.url;
        data["fileName"] = this.fileName;
        data["sizeInBytes"] = this.sizeInBytes;
        return data;
    }
}

export interface IMessageAttachmentItemDto {
    url?: string | undefined;
    fileName?: string | undefined;
    sizeInBytes?: number;
}

export class MessageItemDto implements IMessageItemDto {
    id?: number;
    fromUserId?: number;
    text?: string | undefined;
    sentTime?: Date;
    isMessageRead?: boolean;
    attachments?: MessageAttachmentItemDto[] | undefined;

    constructor(data?: IMessageItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.fromUserId = _data["fromUserId"];
            this.text = _data["text"];
            this.sentTime = _data["sentTime"] ? new Date(_data["sentTime"].toString()) : <any>undefined;
            this.isMessageRead = _data["isMessageRead"];
            if (Array.isArray(_data["attachments"])) {
                this.attachments = [] as any;
                for (let item of _data["attachments"])
                    this.attachments!.push(MessageAttachmentItemDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): MessageItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new MessageItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["fromUserId"] = this.fromUserId;
        data["text"] = this.text;
        data["sentTime"] = this.sentTime ? this.sentTime.toISOString() : <any>undefined;
        data["isMessageRead"] = this.isMessageRead;
        if (Array.isArray(this.attachments)) {
            data["attachments"] = [];
            for (let item of this.attachments)
                data["attachments"].push(item ? item.toJSON() : <any>undefined);
        }
        return data;
    }
}

export interface IMessageItemDto {
    id?: number;
    fromUserId?: number;
    text?: string | undefined;
    sentTime?: Date;
    isMessageRead?: boolean;
    attachments?: MessageAttachmentItemDto[] | undefined;
}

export class NewPaymentItem implements INewPaymentItem {
    paymentSubjectId!: number;
    type!: PaymentType;
    timePeriod!: PostTimeDto;

    constructor(data?: INewPaymentItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.timePeriod = new PostTimeDto();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.paymentSubjectId = _data["paymentSubjectId"];
            this.type = _data["type"];
            this.timePeriod = _data["timePeriod"] ? PostTimeDto.fromJS(_data["timePeriod"]) : new PostTimeDto();
        }
    }

    static fromJS(data: any): NewPaymentItem {
        data = typeof data === 'object' ? data : {};
        let result = new NewPaymentItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["paymentSubjectId"] = this.paymentSubjectId;
        data["type"] = this.type;
        data["timePeriod"] = this.timePeriod ? this.timePeriod.toJSON() : <any>undefined;
        return data;
    }
}

export interface INewPaymentItem {
    paymentSubjectId: number;
    type: PaymentType;
    timePeriod: PostTimeDto;
}

export class NotFoundResult implements INotFoundResult {
    statusCode?: number;

    constructor(data?: INotFoundResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.statusCode = _data["statusCode"];
        }
    }

    static fromJS(data: any): NotFoundResult {
        data = typeof data === 'object' ? data : {};
        let result = new NotFoundResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["statusCode"] = this.statusCode;
        return data;
    }
}

export interface INotFoundResult {
    statusCode?: number;
}

export class NotificationSubscriptionItem implements INotificationSubscriptionItem {
    id?: number;
    title?: string | undefined;
    keywords?: string[] | undefined;
    status?: PaymentSubjectStatus;
    createdDate?: Date | undefined;
    validToDate?: Date | undefined;
    categoryName?: string | undefined;

    constructor(data?: INotificationSubscriptionItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            if (Array.isArray(_data["keywords"])) {
                this.keywords = [] as any;
                for (let item of _data["keywords"])
                    this.keywords!.push(item);
            }
            this.status = _data["status"];
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.validToDate = _data["validToDate"] ? new Date(_data["validToDate"].toString()) : <any>undefined;
            this.categoryName = _data["categoryName"];
        }
    }

    static fromJS(data: any): NotificationSubscriptionItem {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationSubscriptionItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        if (Array.isArray(this.keywords)) {
            data["keywords"] = [];
            for (let item of this.keywords)
                data["keywords"].push(item);
        }
        data["status"] = this.status;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["validToDate"] = this.validToDate ? this.validToDate.toISOString() : <any>undefined;
        data["categoryName"] = this.categoryName;
        return data;
    }
}

export interface INotificationSubscriptionItem {
    id?: number;
    title?: string | undefined;
    keywords?: string[] | undefined;
    status?: PaymentSubjectStatus;
    createdDate?: Date | undefined;
    validToDate?: Date | undefined;
    categoryName?: string | undefined;
}

export class NotificationSubscriptionItemDataTableQueryResponse implements INotificationSubscriptionItemDataTableQueryResponse {
    draw?: number;
    recordsTotal?: number;
    recordsFiltered?: number;
    data?: NotificationSubscriptionItem[] | undefined;
    aggregates?: { [key: string]: any; } | undefined;
    error?: string | undefined;

    constructor(data?: INotificationSubscriptionItemDataTableQueryResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.draw = _data["draw"];
            this.recordsTotal = _data["recordsTotal"];
            this.recordsFiltered = _data["recordsFiltered"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(NotificationSubscriptionItem.fromJS(item));
            }
            if (_data["aggregates"]) {
                this.aggregates = {} as any;
                for (let key in _data["aggregates"]) {
                    if (_data["aggregates"].hasOwnProperty(key))
                        (<any>this.aggregates)![key] = _data["aggregates"][key];
                }
            }
            this.error = _data["error"];
        }
    }

    static fromJS(data: any): NotificationSubscriptionItemDataTableQueryResponse {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationSubscriptionItemDataTableQueryResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["draw"] = this.draw;
        data["recordsTotal"] = this.recordsTotal;
        data["recordsFiltered"] = this.recordsFiltered;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item ? item.toJSON() : <any>undefined);
        }
        if (this.aggregates) {
            data["aggregates"] = {};
            for (let key in this.aggregates) {
                if (this.aggregates.hasOwnProperty(key))
                    (<any>data["aggregates"])[key] = (<any>this.aggregates)[key];
            }
        }
        data["error"] = this.error;
        return data;
    }
}

export interface INotificationSubscriptionItemDataTableQueryResponse {
    draw?: number;
    recordsTotal?: number;
    recordsFiltered?: number;
    data?: NotificationSubscriptionItem[] | undefined;
    aggregates?: { [key: string]: any; } | undefined;
    error?: string | undefined;
}

export class Ok implements IOk {
    readonly statusCode?: number;

    constructor(data?: IOk) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).statusCode = _data["statusCode"];
        }
    }

    static fromJS(data: any): Ok {
        data = typeof data === 'object' ? data : {};
        let result = new Ok();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["statusCode"] = this.statusCode;
        return data;
    }
}

export interface IOk {
    statusCode?: number;
}

export class OkResult implements IOkResult {
    statusCode?: number;

    constructor(data?: IOkResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.statusCode = _data["statusCode"];
        }
    }

    static fromJS(data: any): OkResult {
        data = typeof data === 'object' ? data : {};
        let result = new OkResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["statusCode"] = this.statusCode;
        return data;
    }
}

export interface IOkResult {
    statusCode?: number;
}

export class OrderQuery implements IOrderQuery {
    column?: number;
    direction?: string | undefined;

    constructor(data?: IOrderQuery) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.column = _data["column"];
            this.direction = _data["direction"];
        }
    }

    static fromJS(data: any): OrderQuery {
        data = typeof data === 'object' ? data : {};
        let result = new OrderQuery();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["column"] = this.column;
        data["direction"] = this.direction;
        return data;
    }
}

export interface IOrderQuery {
    column?: number;
    direction?: string | undefined;
}

export class PaymentDataTableQuery implements IPaymentDataTableQuery {
    start?: number | undefined;
    length?: number | undefined;
    search?: SearchQuery | undefined;
    order?: OrderQuery[] | undefined;
    columns?: TableColumn[] | undefined;
    fromDate?: Date | undefined;
    toDate?: Date | undefined;

    constructor(data?: IPaymentDataTableQuery) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.start = _data["start"];
            this.length = _data["length"];
            this.search = _data["search"] ? SearchQuery.fromJS(_data["search"]) : <any>undefined;
            if (Array.isArray(_data["order"])) {
                this.order = [] as any;
                for (let item of _data["order"])
                    this.order!.push(OrderQuery.fromJS(item));
            }
            if (Array.isArray(_data["columns"])) {
                this.columns = [] as any;
                for (let item of _data["columns"])
                    this.columns!.push(TableColumn.fromJS(item));
            }
            this.fromDate = _data["fromDate"] ? new Date(_data["fromDate"].toString()) : <any>undefined;
            this.toDate = _data["toDate"] ? new Date(_data["toDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): PaymentDataTableQuery {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentDataTableQuery();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["start"] = this.start;
        data["length"] = this.length;
        data["search"] = this.search ? this.search.toJSON() : <any>undefined;
        if (Array.isArray(this.order)) {
            data["order"] = [];
            for (let item of this.order)
                data["order"].push(item ? item.toJSON() : <any>undefined);
        }
        if (Array.isArray(this.columns)) {
            data["columns"] = [];
            for (let item of this.columns)
                data["columns"].push(item ? item.toJSON() : <any>undefined);
        }
        data["fromDate"] = this.fromDate ? this.fromDate.toISOString() : <any>undefined;
        data["toDate"] = this.toDate ? this.toDate.toISOString() : <any>undefined;
        return data;
    }
}

export interface IPaymentDataTableQuery {
    start?: number | undefined;
    length?: number | undefined;
    search?: SearchQuery | undefined;
    order?: OrderQuery[] | undefined;
    columns?: TableColumn[] | undefined;
    fromDate?: Date | undefined;
    toDate?: Date | undefined;
}

export class PaymentItemDto implements IPaymentItemDto {
    paymentSubjectId?: number;
    type?: PaymentType;
    title?: string | undefined;
    price?: number;
    timePeriod?: PostTimeDto | undefined;

    constructor(data?: IPaymentItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.paymentSubjectId = _data["paymentSubjectId"];
            this.type = _data["type"];
            this.title = _data["title"];
            this.price = _data["price"];
            this.timePeriod = _data["timePeriod"] ? PostTimeDto.fromJS(_data["timePeriod"]) : <any>undefined;
        }
    }

    static fromJS(data: any): PaymentItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["paymentSubjectId"] = this.paymentSubjectId;
        data["type"] = this.type;
        data["title"] = this.title;
        data["price"] = this.price;
        data["timePeriod"] = this.timePeriod ? this.timePeriod.toJSON() : <any>undefined;
        return data;
    }
}

export interface IPaymentItemDto {
    paymentSubjectId?: number;
    type?: PaymentType;
    title?: string | undefined;
    price?: number;
    timePeriod?: PostTimeDto | undefined;
}

export class PaymentListItem implements IPaymentListItem {
    id?: number;
    amount?: number;
    payerId?: number;
    date?: Date;
    paymentItemCount?: number;

    constructor(data?: IPaymentListItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.amount = _data["amount"];
            this.payerId = _data["payerId"];
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
            this.paymentItemCount = _data["paymentItemCount"];
        }
    }

    static fromJS(data: any): PaymentListItem {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentListItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["amount"] = this.amount;
        data["payerId"] = this.payerId;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["paymentItemCount"] = this.paymentItemCount;
        return data;
    }
}

export interface IPaymentListItem {
    id?: number;
    amount?: number;
    payerId?: number;
    date?: Date;
    paymentItemCount?: number;
}

export class PaymentListItemDataTableQueryResponse implements IPaymentListItemDataTableQueryResponse {
    draw?: number;
    recordsTotal?: number;
    recordsFiltered?: number;
    data?: PaymentListItem[] | undefined;
    aggregates?: { [key: string]: any; } | undefined;
    error?: string | undefined;

    constructor(data?: IPaymentListItemDataTableQueryResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.draw = _data["draw"];
            this.recordsTotal = _data["recordsTotal"];
            this.recordsFiltered = _data["recordsFiltered"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(PaymentListItem.fromJS(item));
            }
            if (_data["aggregates"]) {
                this.aggregates = {} as any;
                for (let key in _data["aggregates"]) {
                    if (_data["aggregates"].hasOwnProperty(key))
                        (<any>this.aggregates)![key] = _data["aggregates"][key];
                }
            }
            this.error = _data["error"];
        }
    }

    static fromJS(data: any): PaymentListItemDataTableQueryResponse {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentListItemDataTableQueryResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["draw"] = this.draw;
        data["recordsTotal"] = this.recordsTotal;
        data["recordsFiltered"] = this.recordsFiltered;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item ? item.toJSON() : <any>undefined);
        }
        if (this.aggregates) {
            data["aggregates"] = {};
            for (let key in this.aggregates) {
                if (this.aggregates.hasOwnProperty(key))
                    (<any>data["aggregates"])[key] = (<any>this.aggregates)[key];
            }
        }
        data["error"] = this.error;
        return data;
    }
}

export interface IPaymentListItemDataTableQueryResponse {
    draw?: number;
    recordsTotal?: number;
    recordsFiltered?: number;
    data?: PaymentListItem[] | undefined;
    aggregates?: { [key: string]: any; } | undefined;
    error?: string | undefined;
}

export enum PaymentSubjectStatus {
    Draft = "Draft",
    Active = "Active",
    Inactive = "Inactive",
    Expired = "Expired",
}

export enum PaymentType {
    CreateAdvertisement = "CreateAdvertisement",
    ExtendAdvertisement = "ExtendAdvertisement",
    CreateAdvertisementNotificationSubscription = "CreateAdvertisementNotificationSubscription",
    ExtendAdvertisementNotificationSubscription = "ExtendAdvertisementNotificationSubscription",
}

export class PostTimeDto implements IPostTimeDto {
    days?: number;
    weeks?: number;
    months?: number;

    constructor(data?: IPostTimeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.days = _data["days"];
            this.weeks = _data["weeks"];
            this.months = _data["months"];
        }
    }

    static fromJS(data: any): PostTimeDto {
        data = typeof data === 'object' ? data : {};
        let result = new PostTimeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["days"] = this.days;
        data["weeks"] = this.weeks;
        data["months"] = this.months;
        return data;
    }
}

export interface IPostTimeDto {
    days?: number;
    weeks?: number;
    months?: number;
}

export class PriceInfo implements IPriceInfo {
    items?: PaymentItemDto[] | undefined;
    totalAmount?: number;
    date?: Date | undefined;

    constructor(data?: IPriceInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(PaymentItemDto.fromJS(item));
            }
            this.totalAmount = _data["totalAmount"];
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): PriceInfo {
        data = typeof data === 'object' ? data : {};
        let result = new PriceInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item ? item.toJSON() : <any>undefined);
        }
        data["totalAmount"] = this.totalAmount;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        return data;
    }
}

export interface IPriceInfo {
    items?: PaymentItemDto[] | undefined;
    totalAmount?: number;
    date?: Date | undefined;
}

export class PublicUserInfoDto implements IPublicUserInfoDto {
    id?: number;
    userName?: string | undefined;
    email?: string | undefined;
    phoneNumber?: string | undefined;
    linkToUserSite?: string | undefined;
    profileImageUrl?: string | undefined;

    constructor(data?: IPublicUserInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userName = _data["userName"];
            this.email = _data["email"];
            this.phoneNumber = _data["phoneNumber"];
            this.linkToUserSite = _data["linkToUserSite"];
            this.profileImageUrl = _data["profileImageUrl"];
        }
    }

    static fromJS(data: any): PublicUserInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new PublicUserInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userName"] = this.userName;
        data["email"] = this.email;
        data["phoneNumber"] = this.phoneNumber;
        data["linkToUserSite"] = this.linkToUserSite;
        data["profileImageUrl"] = this.profileImageUrl;
        return data;
    }
}

export interface IPublicUserInfoDto {
    id?: number;
    userName?: string | undefined;
    email?: string | undefined;
    phoneNumber?: string | undefined;
    linkToUserSite?: string | undefined;
    profileImageUrl?: string | undefined;
}

export class PutCategoryRequest implements IPutCategoryRequest {
    id?: number | undefined;
    localizedNames!: StringStringKeyValuePair[];
    canContainAdvertisements!: boolean;
    parentCategoryId?: number | undefined;
    categoryAttributeOrder!: Int32StringKeyValuePair[];

    constructor(data?: IPutCategoryRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.localizedNames = [];
            this.categoryAttributeOrder = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            if (Array.isArray(_data["localizedNames"])) {
                this.localizedNames = [] as any;
                for (let item of _data["localizedNames"])
                    this.localizedNames!.push(StringStringKeyValuePair.fromJS(item));
            }
            this.canContainAdvertisements = _data["canContainAdvertisements"];
            this.parentCategoryId = _data["parentCategoryId"];
            if (Array.isArray(_data["categoryAttributeOrder"])) {
                this.categoryAttributeOrder = [] as any;
                for (let item of _data["categoryAttributeOrder"])
                    this.categoryAttributeOrder!.push(Int32StringKeyValuePair.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PutCategoryRequest {
        data = typeof data === 'object' ? data : {};
        let result = new PutCategoryRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        if (Array.isArray(this.localizedNames)) {
            data["localizedNames"] = [];
            for (let item of this.localizedNames)
                data["localizedNames"].push(item ? item.toJSON() : <any>undefined);
        }
        data["canContainAdvertisements"] = this.canContainAdvertisements;
        data["parentCategoryId"] = this.parentCategoryId;
        if (Array.isArray(this.categoryAttributeOrder)) {
            data["categoryAttributeOrder"] = [];
            for (let item of this.categoryAttributeOrder)
                data["categoryAttributeOrder"].push(item ? item.toJSON() : <any>undefined);
        }
        return data;
    }
}

export interface IPutCategoryRequest {
    id?: number | undefined;
    localizedNames: StringStringKeyValuePair[];
    canContainAdvertisements: boolean;
    parentCategoryId?: number | undefined;
    categoryAttributeOrder: Int32StringKeyValuePair[];
}

export class RefreshRequest implements IRefreshRequest {
    refreshToken!: string | undefined;

    constructor(data?: IRefreshRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.refreshToken = _data["refreshToken"];
        }
    }

    static fromJS(data: any): RefreshRequest {
        data = typeof data === 'object' ? data : {};
        let result = new RefreshRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["refreshToken"] = this.refreshToken;
        return data;
    }
}

export interface IRefreshRequest {
    refreshToken: string | undefined;
}

export class RegisterDto implements IRegisterDto {
    email!: string;
    isEmailPublic?: boolean;
    password!: string;
    passwordConfirmation!: string;
    firstName!: string;
    lastName!: string;
    userName!: string;
    phoneNumber!: string;
    isPhoneNumberPublic?: boolean;
    profileImage?: any | undefined;

    constructor(data?: IRegisterDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.isEmailPublic = _data["isEmailPublic"];
            this.password = _data["password"];
            this.passwordConfirmation = _data["passwordConfirmation"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.userName = _data["userName"];
            this.phoneNumber = _data["phoneNumber"];
            this.isPhoneNumberPublic = _data["isPhoneNumberPublic"];
            this.profileImage = _data["profileImage"];
        }
    }

    static fromJS(data: any): RegisterDto {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["isEmailPublic"] = this.isEmailPublic;
        data["password"] = this.password;
        data["passwordConfirmation"] = this.passwordConfirmation;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["userName"] = this.userName;
        data["phoneNumber"] = this.phoneNumber;
        data["isPhoneNumberPublic"] = this.isPhoneNumberPublic;
        data["profileImage"] = this.profileImage;
        return data;
    }
}

export interface IRegisterDto {
    email: string;
    isEmailPublic?: boolean;
    password: string;
    passwordConfirmation: string;
    firstName: string;
    lastName: string;
    userName: string;
    phoneNumber: string;
    isPhoneNumberPublic?: boolean;
    profileImage?: any | undefined;
}

export class ReportAdvertisementRequest implements IReportAdvertisementRequest {
    description!: string;
    reportedAdvertisementId!: number;

    constructor(data?: IReportAdvertisementRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.description = _data["description"];
            this.reportedAdvertisementId = _data["reportedAdvertisementId"];
        }
    }

    static fromJS(data: any): ReportAdvertisementRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ReportAdvertisementRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["description"] = this.description;
        data["reportedAdvertisementId"] = this.reportedAdvertisementId;
        return data;
    }
}

export interface IReportAdvertisementRequest {
    description: string;
    reportedAdvertisementId: number;
}

export class RequestExceptionResponse implements IRequestExceptionResponse {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;
    errors?: { [key: string]: string[]; } | undefined;
    errorCodes?: string[] | undefined;

    [key: string]: any;

    constructor(data?: IRequestExceptionResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.type = _data["type"];
            this.title = _data["title"];
            this.status = _data["status"];
            this.detail = _data["detail"];
            this.instance = _data["instance"];
            if (_data["errors"]) {
                this.errors = {} as any;
                for (let key in _data["errors"]) {
                    if (_data["errors"].hasOwnProperty(key))
                        (<any>this.errors)![key] = _data["errors"][key] !== undefined ? _data["errors"][key] : [];
                }
            }
            if (Array.isArray(_data["errorCodes"])) {
                this.errorCodes = [] as any;
                for (let item of _data["errorCodes"])
                    this.errorCodes!.push(item);
            }
        }
    }

    static fromJS(data: any): RequestExceptionResponse {
        data = typeof data === 'object' ? data : {};
        let result = new RequestExceptionResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["type"] = this.type;
        data["title"] = this.title;
        data["status"] = this.status;
        data["detail"] = this.detail;
        data["instance"] = this.instance;
        if (this.errors) {
            data["errors"] = {};
            for (let key in this.errors) {
                if (this.errors.hasOwnProperty(key))
                    (<any>data["errors"])[key] = (<any>this.errors)[key];
            }
        }
        if (Array.isArray(this.errorCodes)) {
            data["errorCodes"] = [];
            for (let item of this.errorCodes)
                data["errorCodes"].push(item);
        }
        return data;
    }
}

export interface IRequestExceptionResponse {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;
    errors?: { [key: string]: string[]; } | undefined;
    errorCodes?: string[] | undefined;

    [key: string]: any;
}

export class SearchQuery implements ISearchQuery {
    value?: string | undefined;
    regex?: boolean;

    constructor(data?: ISearchQuery) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.value = _data["value"];
            this.regex = _data["regex"];
        }
    }

    static fromJS(data: any): SearchQuery {
        data = typeof data === 'object' ? data : {};
        let result = new SearchQuery();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        data["regex"] = this.regex;
        return data;
    }
}

export interface ISearchQuery {
    value?: string | undefined;
    regex?: boolean;
}

export class SendMessageRequest implements ISendMessageRequest {
    chatId!: number;
    text!: string;
    attachments?: any[] | undefined;

    constructor(data?: ISendMessageRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.chatId = _data["chatId"];
            this.text = _data["text"];
            if (Array.isArray(_data["attachments"])) {
                this.attachments = [] as any;
                for (let item of _data["attachments"])
                    this.attachments!.push(item);
            }
        }
    }

    static fromJS(data: any): SendMessageRequest {
        data = typeof data === 'object' ? data : {};
        let result = new SendMessageRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["chatId"] = this.chatId;
        data["text"] = this.text;
        if (Array.isArray(this.attachments)) {
            data["attachments"] = [];
            for (let item of this.attachments)
                data["attachments"].push(item);
        }
        return data;
    }
}

export interface ISendMessageRequest {
    chatId: number;
    text: string;
    attachments?: any[] | undefined;
}

export class SetActiveStatusRequest implements ISetActiveStatusRequest {
    ids!: number[];
    isActive!: boolean;

    constructor(data?: ISetActiveStatusRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.ids = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["ids"])) {
                this.ids = [] as any;
                for (let item of _data["ids"])
                    this.ids!.push(item);
            }
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): SetActiveStatusRequest {
        data = typeof data === 'object' ? data : {};
        let result = new SetActiveStatusRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.ids)) {
            data["ids"] = [];
            for (let item of this.ids)
                data["ids"].push(item);
        }
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface ISetActiveStatusRequest {
    ids: number[];
    isActive: boolean;
}

export class StringStringKeyValuePair implements IStringStringKeyValuePair {
    key?: string | undefined;
    value?: string | undefined;

    constructor(data?: IStringStringKeyValuePair) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.key = _data["key"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): StringStringKeyValuePair {
        data = typeof data === 'object' ? data : {};
        let result = new StringStringKeyValuePair();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        data["value"] = this.value;
        return data;
    }
}

export interface IStringStringKeyValuePair {
    key?: string | undefined;
    value?: string | undefined;
}

export class SubscriptionFormInfo implements ISubscriptionFormInfo {
    subscription?: CreateOrEditNotificationSubscriptionRequest | undefined;
    categoryInfo?: CategoryAttributeListData | undefined;

    constructor(data?: ISubscriptionFormInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.subscription = _data["subscription"] ? CreateOrEditNotificationSubscriptionRequest.fromJS(_data["subscription"]) : <any>undefined;
            this.categoryInfo = _data["categoryInfo"] ? CategoryAttributeListData.fromJS(_data["categoryInfo"]) : <any>undefined;
        }
    }

    static fromJS(data: any): SubscriptionFormInfo {
        data = typeof data === 'object' ? data : {};
        let result = new SubscriptionFormInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["subscription"] = this.subscription ? this.subscription.toJSON() : <any>undefined;
        data["categoryInfo"] = this.categoryInfo ? this.categoryInfo.toJSON() : <any>undefined;
        return data;
    }
}

export interface ISubscriptionFormInfo {
    subscription?: CreateOrEditNotificationSubscriptionRequest | undefined;
    categoryInfo?: CategoryAttributeListData | undefined;
}

export class T implements IT {

    constructor(data?: IT) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): T {
        data = typeof data === 'object' ? data : {};
        let result = new T();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data;
    }
}

export interface IT {
}

export class TableColumn implements ITableColumn {
    data?: string | undefined;
    name?: string | undefined;
    searchable?: boolean;
    orderable?: boolean;
    aggregate?: boolean;
    search?: SearchQuery | undefined;

    constructor(data?: ITableColumn) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"];
            this.name = _data["name"];
            this.searchable = _data["searchable"];
            this.orderable = _data["orderable"];
            this.aggregate = _data["aggregate"];
            this.search = _data["search"] ? SearchQuery.fromJS(_data["search"]) : <any>undefined;
        }
    }

    static fromJS(data: any): TableColumn {
        data = typeof data === 'object' ? data : {};
        let result = new TableColumn();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data;
        data["name"] = this.name;
        data["searchable"] = this.searchable;
        data["orderable"] = this.orderable;
        data["aggregate"] = this.aggregate;
        data["search"] = this.search ? this.search.toJSON() : <any>undefined;
        return data;
    }
}

export interface ITableColumn {
    data?: string | undefined;
    name?: string | undefined;
    searchable?: boolean;
    orderable?: boolean;
    aggregate?: boolean;
    search?: SearchQuery | undefined;
}

export class UnauthorizedHttpResult implements IUnauthorizedHttpResult {
    readonly statusCode?: number;

    constructor(data?: IUnauthorizedHttpResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).statusCode = _data["statusCode"];
        }
    }

    static fromJS(data: any): UnauthorizedHttpResult {
        data = typeof data === 'object' ? data : {};
        let result = new UnauthorizedHttpResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["statusCode"] = this.statusCode;
        return data;
    }
}

export interface IUnauthorizedHttpResult {
    statusCode?: number;
}

export class UserInfo implements IUserInfo {
    id?: number;
    firstName?: string | undefined;
    lastName?: string | undefined;
    userName?: string | undefined;
    isPhoneNumberPublic?: boolean;
    phoneNumber?: string | undefined;
    isEmailPublic?: boolean;
    email?: string | undefined;
    linkToUserSite?: string | undefined;
    profileImage?: ImageDto | undefined;

    constructor(data?: IUserInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.userName = _data["userName"];
            this.isPhoneNumberPublic = _data["isPhoneNumberPublic"];
            this.phoneNumber = _data["phoneNumber"];
            this.isEmailPublic = _data["isEmailPublic"];
            this.email = _data["email"];
            this.linkToUserSite = _data["linkToUserSite"];
            this.profileImage = _data["profileImage"] ? ImageDto.fromJS(_data["profileImage"]) : <any>undefined;
        }
    }

    static fromJS(data: any): UserInfo {
        data = typeof data === 'object' ? data : {};
        let result = new UserInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["userName"] = this.userName;
        data["isPhoneNumberPublic"] = this.isPhoneNumberPublic;
        data["phoneNumber"] = this.phoneNumber;
        data["isEmailPublic"] = this.isEmailPublic;
        data["email"] = this.email;
        data["linkToUserSite"] = this.linkToUserSite;
        data["profileImage"] = this.profileImage ? this.profileImage.toJSON() : <any>undefined;
        return data;
    }
}

export interface IUserInfo {
    id?: number;
    firstName?: string | undefined;
    lastName?: string | undefined;
    userName?: string | undefined;
    isPhoneNumberPublic?: boolean;
    phoneNumber?: string | undefined;
    isEmailPublic?: boolean;
    email?: string | undefined;
    linkToUserSite?: string | undefined;
    profileImage?: ImageDto | undefined;
}

export class UserListItem implements IUserListItem {
    id?: number;
    firstName?: string | undefined;
    lastName?: string | undefined;

    constructor(data?: IUserListItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
        }
    }

    static fromJS(data: any): UserListItem {
        data = typeof data === 'object' ? data : {};
        let result = new UserListItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        return data;
    }
}

export interface IUserListItem {
    id?: number;
    firstName?: string | undefined;
    lastName?: string | undefined;
}

export class UserListItemDataTableQueryResponse implements IUserListItemDataTableQueryResponse {
    draw?: number;
    recordsTotal?: number;
    recordsFiltered?: number;
    data?: UserListItem[] | undefined;
    aggregates?: { [key: string]: any; } | undefined;
    error?: string | undefined;

    constructor(data?: IUserListItemDataTableQueryResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.draw = _data["draw"];
            this.recordsTotal = _data["recordsTotal"];
            this.recordsFiltered = _data["recordsFiltered"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(UserListItem.fromJS(item));
            }
            if (_data["aggregates"]) {
                this.aggregates = {} as any;
                for (let key in _data["aggregates"]) {
                    if (_data["aggregates"].hasOwnProperty(key))
                        (<any>this.aggregates)![key] = _data["aggregates"][key];
                }
            }
            this.error = _data["error"];
        }
    }

    static fromJS(data: any): UserListItemDataTableQueryResponse {
        data = typeof data === 'object' ? data : {};
        let result = new UserListItemDataTableQueryResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["draw"] = this.draw;
        data["recordsTotal"] = this.recordsTotal;
        data["recordsFiltered"] = this.recordsFiltered;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item ? item.toJSON() : <any>undefined);
        }
        if (this.aggregates) {
            data["aggregates"] = {};
            for (let key in this.aggregates) {
                if (this.aggregates.hasOwnProperty(key))
                    (<any>data["aggregates"])[key] = (<any>this.aggregates)[key];
            }
        }
        data["error"] = this.error;
        return data;
    }
}

export interface IUserListItemDataTableQueryResponse {
    draw?: number;
    recordsTotal?: number;
    recordsFiltered?: number;
    data?: UserListItem[] | undefined;
    aggregates?: { [key: string]: any; } | undefined;
    error?: string | undefined;
}

export enum ValueTypes {
    Text = "Text",
    Integer = "Integer",
    Decimal = "Decimal",
    ValueListEntry = "ValueListEntry",
}

export interface FileParameter {
    data: any;
    fileName: string;
}

export interface FileResponse {
    data: Blob;
    status: number;
    fileName?: string;
    headers?: { [name: string]: any };
}

export class ApiException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}

function isAxiosError(obj: any): obj is AxiosError {
    return obj && obj.isAxiosError === true;
}